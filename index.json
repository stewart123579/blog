[{"content":"It\u0026rsquo;s exciting that my contributions to magicl have been merged into the main branch.\nmagicl is Matrix Algebra proGrams In Common Lisp, you could think of it as a lisp version of NumPy, but easier to extend.\nNow on to using this new functionality in a machine learning example.\n","permalink":"https://stewart123579.github.io/blog/posts/code/magicl-contributions/","summary":"\u003cp\u003eIt\u0026rsquo;s exciting that \u003ca href=\"https://github.com/quil-lang/magicl/commits?author=stewart123579\"\u003emy contributions\u003c/a\u003e to \u003ca href=\"https://github.com/quil-lang/magicl\"\u003emagicl\u003c/a\u003e have been merged into the main branch.\u003c/p\u003e","title":"magicl contributions"},{"content":"What does optimised pure lisp look like?\nIn my previous post on Calculating a DOT product  I mentioned making a fast pure lisp implementation of the dot product function. Let\u0026rsquo;s dig into that.\nLet\u0026rsquo;s see if we can compete with the magicl code, or the highly optimised C code in numpy. My goals to explore are twofold:\n Make pure lisp code comparable in speed to the R and python best cases Make the code readable, we\u0026rsquo;re not going to use fancy tricks or algorithms, or reduce readability (too highly optimised code leads to hard to identify bugs and difficulties maintaining!)  This post is heavily motivated by the magicl dot product code and it appears in the following categories:  AI / ML in common lisp \u0026mdash; Implementing AI and Machine Learning tools in common lisp.\n code  Initial setup As we did previously, let\u0026rsquo;s create two lists, each being 10 million random numbers between 0 and 1.\n(defun randvect (length) \u0026#34;A simple list (length LENTH) of random numbers [0,1)\u0026#34; (loop for i below length collect (random 1.0))) (defvar n 10000000 \u0026#34;The length of our test data\u0026#34;) (defvar a (randvect n) \u0026#34;A list, length N, of random numbers\u0026#34;) (defvar b (randvect n) \u0026#34;Another list, length N, of random numbers\u0026#34;) Thinking about how we should store our data  lists versus arrays lists aren\u0026rsquo;t ideal for storing vectors, lookup speed grows with length, whilst arrays have a constant time. This is important when building models, where the list/array might be 10 million (or more) observations of our experiment   (defparameter array-a (make-array (list (length a)) :initial-contents a)) (defparameter array-b (make-array (list (length b)) :initial-contents b)) Previous version of the code This is the code I had for na√Øve-dot-v2 (which I\u0026rsquo;m calling v1 here)\n(loop for i below (length array-a) sum (* (aref array-a i) (aref array-b i))) v1 - 270.0504ms Let\u0026rsquo;s turn this into a function so we can optimise it\u0026hellip;\n(defun dot-v2 (array1 array2) (loop for i below (length array1) sum (* (aref array1 i) (aref array2 i)))) v2 - 234.21423ms Adding a check Before we optimise the code, we should add a check to make sure the arrays are the same size:\n(defun dot-v3 (array1 array2) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 sum (* (aref array1 i) (aref array2 i))))) v3 - 220.24509ms I\u0026rsquo;ve created two new variables size1 and size2 and assert that they are equal.\nI\u0026rsquo;m not really sure why this was faster, it was probably a function of whatever else was (or wasn\u0026rsquo;t) running on my machine at the time, but it\u0026rsquo;s not really material.\nI want speed! Let\u0026rsquo;s be clear - we want to optimise for SPEED, so be explicit in line 2.\n1 2 3 4 5 6 7  (defun dot-v4 (array1 array2) (declare (optimize speed)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 sum (* (aref array1 i) (aref array2 i)))))   v4 - 222.48372ms No improvement!\nWhy? We haven\u0026rsquo;t given any hints to the how the compiler/interpreter can improve things. Let\u0026rsquo;s remove the optimise command and add some type hints.\nAdding data type information Now let\u0026rsquo;s use lisp\u0026rsquo;s gradual typing features. I\u0026rsquo;m planning to write about this in another post (and I\u0026rsquo;ll update this one to point to it).\n data type Python and R are making assumptions on the data we\u0026rsquo;re storing, they\u0026rsquo;re both assuming floating point numbers.  How do I this in lisp? Easily. We just add :element-type 'single-float to the make-array command. This is exactly comparable to the dtype=float32 flag you\u0026rsquo;d use in python\u0026rsquo;s NumPy/TensorFlow/etc.\n(defparameter array-a-v2 (make-array (list (length a)) :initial-contents a :element-type \u0026#39;single-float)) (defparameter array-b-v2 (make-array (list (length b)) :initial-contents b :element-type \u0026#39;single-float)) Gradual typing is where we can define the type of data in a particular function - but we don\u0026rsquo;t have to everywhere. (Most) Other languages have an all-or-nothing approach, but lisp allows you to choose.\nBelow, in line 2, we simply declare that the type of the inputs array1 and array2 are simple-array single-float (*), which means:\n simple-array just take this as it reads - a simple array - or dig into the CLHS for details single-float elements are floating point numbers (as opposed to, say double precision or complex numbers) (*) indicates this is a single dimensional array, i.e. vector, of unknown size   1 2 3 4 5 6 7  (defun dot-v5 (array1 array2) (declare (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 sum (* (aref array1 i) (aref array2 i)))))   v5 - 120.991104ms We\u0026rsquo;ve almost halved the run time - because the multiplication on line 7 now can be simplified to only handle single-float arguments rather than a generic operation that works for integers, single and double floats, ratios, complex numbers, \u0026hellip;\nAdding type information to the loop: the accumulator We have now optimised our multiplication to work for out single-float arguments, but the accumulator (i.e. the sum part) in the loop function doesn\u0026rsquo;t know the type of it\u0026rsquo;s arguments. However, we do. The sum of two values of type single-float is another single-float. In line 7 we use that information:\n1 2 3 4 5 6 7 8 9  (defun dot-v6 (array1 array2) (declare (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 with s of-type single-float = 0.0 do (incf s (* (aref array1 i) (aref array2 i))) finally (return s))))   We\u0026rsquo;ve also had to add lines 8 and 9 to replicate what the sum keyword is providing in the loop.\nThe results were staggering when I first saw them.\nv6 - 11.116839ms We took an order of magnitude off the run-time and are now in the realms of the NumPy - hand tuned, optimised and mostly unreadable, C.\nOptimise for speed, again Again, let\u0026rsquo;s be explicit that we want SPEED.\n(defun dot-v7 (array1 array2) (declare (optimize speed) (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 with s of-type single-float = 0.0 do (incf s (* (aref array1 i) (aref array2 i))) finally (return s)))) The lisp implementation I\u0026rsquo;m using (SBCL) is already a high performance Common Lisp compiler, so there\u0026rsquo;s not much to be squeezed out here.\nv7 - 10.600901ms Adding type information to the loop: array index We can help the compiler out a little more by letting it know that the loop variable i is for indexing arrays:\n(defun dot-v8 (array1 array2) (declare (optimize speed) (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i of-type alexandria:array-index below size1 with s of-type single-float = 0.0 do (incf s (* (aref array1 i) (aref array2 i))) finally (return s)))) With this we can squeeze out a little more speed, but to be honest this result fluctuated depending on what else my computer was doing.\nv8 - 10.57616ms Almost the end At this point I would look into defgeneric where I can define multiple dot functions each optimised for different inputs, so double-float, complex-float, etc. This is similar to overloading in other languages. However, I\u0026rsquo;ll leave that for another day.\nNow, if this was a language benchmark post, I\u0026rsquo;d stop here. However, I want to use this dot function in a practical use case. That\u0026rsquo;s what I do in some following articles where I build a AI/ML model  (a neural network in fact) in lisp.\nFinally Let\u0026rsquo;s compare the initial function and the optimised one:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  (defun final-dot (array1 array2) (declare (optimize speed) (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i of-type alexandria:array-index below size1 with s of-type single-float = 0.0 do (incf s (* (aref array1 i) (aref array2 i))) finally (return s)))) (defun initial-dot (array1 array2) (loop for i below (length array1) sum (* (aref array1 i) (aref array2 i))))    Line 1 Defining the function [Same as line 13] Line 2 Tell the compiler we want fast code Line 3 Tell the compiler the arguments are single-float Lines 4 \u0026ndash; 6 Check to see that the vectors are the same length Line 7 Create our iterating variable [Effectively, same as line 14] Line 8 Tell the compiler that our accumulator variable s is a single-float Lines 9 \u0026amp; 10 Sum up the product of the array elements [Same as line 15]  Effectively, by adding lines 3 and 8 we have taken the time to calculate the dot product from 270ms down to 10.576ms, speeding it up by more than 25 times and ending with a run time that is comparable to Numpy (11.154ms - previously ).\nAn aside\u0026hellip; Why did I say the lines 9 \u0026amp; 10 are the same as line 15?\nThe loop macro in common lisp is incredibly versatile.\nThe code generated by these two loops is virtually identical\n;; Loop version 1 (loop for i below 5 sum i) ;; Loop version 2 (loop for i below 5 with s = 0 do (incf s i) finally (return s)) The only real difference is the variable #:LOOP-SUM-708 in this first code block acting as a proxy for S in the second loop.\nThis is the expansion of the first loop (using (macroexpand-1 '(loop for i below 5 sum i))):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  (block nil (let ((i 0)) (declare (ignorable i) (type (and number real) i)) (;; some sbcl specific defintions of the loop ;; variable #:loop-sum-708 (tagbody sb-loop::next-loop (when (\u0026gt;= i \u0026#39;5) (go sb-loop::end-loop)) (setq #:loop-sum-708 (+ #:loop-sum-708 i)) (sb-loop::loop-desetq i (1+ i)) (go sb-loop::next-loop) sb-loop::end-loop (return-from nil #:loop-sum-708)))))   The expansion of the second loop, where lines 5 \u0026amp; 6 (defining the variable S) are the only material differences.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  (block nil (let ((i 0)) (declare (ignorable i) (type (and number real) i)) (let ((s 0)) (declare (ignorable s)) (tagbody sb-loop::next-loop (when (\u0026gt;= i \u0026#39;5) (go sb-loop::end-loop)) (incf s i) (sb-loop::loop-desetq i (1+ i)) (go sb-loop::next-loop) sb-loop::end-loop (return s)))))   In case you were wondering about the (incf s i) in line 10\n(macroexpand-1 \u0026#39;(incf s i)) (setq s (+ i s)) which is the same form as line 10 in the first expansion.\nAren\u0026rsquo;t lisp macros amazing!?\n","permalink":"https://stewart123579.github.io/blog/posts/code/making-pure-lisp-functions-faster/","summary":"\u003cp\u003eWhat does optimised pure lisp look like?\u003c/p\u003e","title":"Making (pure) lisp functions faster"},{"content":"It should go without saying: Choose the right programming language for your problem.\ntl;dr - You can get high speed, numerical calculation output without having to resort to bug-prone, highly tuned and optimised, unreadable code.\nHere I explore the code and efficiency (or more accurately run-time) of taking dot product on two vectors that are each ten million elements long. I\u0026rsquo;ll look at python, R and common lisp and in each case implement the dot product myself as well as using an optimised package for the library. The fastest implementation may surprise you.\nThis is not a post on benchmarking, the timings in the final section aren\u0026rsquo;t taken on a particularly powerful machine1 or intended to be rigorous; the timings are simply to show that rapid prototyping, followed by optimising what matters can be worthwhile. It was, however motivated by my question on Reddit.\nThis post appears in the following categories:  AI / ML in common lisp \u0026mdash; Implementing AI and Machine Learning tools in common lisp.\n code Lisp versus X \u0026mdash; A different perspective is always valuable.  What\u0026rsquo;s a dot product and why do I care? A dot product between two vectors \\(A\\) and \\(B\\) can be thought of as the sum of the product of the elements, i.e.\n\\begin{align} A \\cdot B \u0026amp;=\t\\sum_{i=1}^{n}a_{i}\\,b_{i} \\\\ \u0026amp;= a_{1}\\,b_{1} + a_{2}\\,b_{2} + \\ldots \\end{align}\nSo why do I (or should you) care? Dot products are pretty fundamental to machine learning - as I\u0026rsquo;ll show in some upcoming posts. That means, when you have lots of data, you\u0026rsquo;re doing this operation lots of times. So how well your language implements this matters.\nLet\u0026rsquo;s look at two common (and one not so common2) languages and timings.\nA python implementation Python is the go-to language for machine-learning practitioners currently. There are many extremely powerful frameworks like PyTorch, TensorFlow among others. They are primarily built upon NumPy. If you\u0026rsquo;re reading this post, you probably know all of this.\nLet\u0026rsquo;s set up our random vectors\u0026hellip;\nimport time import numpy as np # How big do we want the vector to be? 10 million! n = 10000000 # Make two arrays of 10 million random numbers a = np.random.rand(n) b = np.random.rand(n) Na√Øve loop If we were to evaluate the dot product with a loop over each of the elements it would look something like\ndef dot_prod_loop(): n = len(a) tic = time.time() c = 0 for i in range(n): c += a[i] * b[i] toc = time.time() print(f\u0026#34;Python: loop version: {1000*(toc-tic):.3f}ms\u0026#34;) # Run it dot_prod_loop() Python: loop version: 3632.499ms NumPy Naturally, we can do better by using the NumPy implementation:\ndef dot_prod_numpy(): tic = time.time() c = np.dot(a,b) toc = time.time() print(f\u0026#34;Python: numpy version: {1000*(toc-tic):.3f}ms\u0026#34;) # Run it dot_prod_numpy() Python: numpy version: 11.154ms So the \u0026ldquo;vectorised\u0026rdquo; python version is about 330 times faster!\nOf course this is a somewhat unfair comparison, because the NumPy version is actually highly optimised and compiled C code. It\u0026rsquo;s not pretty or concise (and that\u0026rsquo;s coming from someone who chooses to code in C!), but it\u0026rsquo;s fast.\nAn alternative implementation in R I used to write a lot in R, so I thought I\u0026rsquo;d dust it off for a comparison.\nSetting our random vectors again\nn \u0026lt;- 10000000 a \u0026lt;- runif(n) b \u0026lt;- runif(n) Na√Øve loop As with the python case loop over each of the elements\n# Loop tic = Sys.time() result = 0 for (i in 1:length(a)) result = result + a[i] * b[i] toc = Sys.time() cat(\u0026#34;R: loop version: \u0026#34;, round(1000*(toc-tic), 3), \u0026#34;ms\\n\u0026#34;) R: loop version: 533.698 ms Around 7 times faster than the na√Øve python implementation. Not bad.\nSum the element-wise multiplication An alternative is to use the built-in element-wise multiplication feature and sum up the results\n# Another simplistic approach tic = Sys.time() result = sum(a*b) toc = Sys.time() cat(\u0026#34;R: summing element-wise multiplication version: \u0026#34;, round(1000*(toc-tic), 3), \u0026#34;ms\\n\u0026#34;) R: summing element-wise multiplication version: 1599.384 ms Ouch. This is not what I would have expected using native functions.\nBuilt-in matrix multiplication As R is a language built for mathematical operations, we could just use the built-in matrix multiplication operation.\n# Built in dot product tic = Sys.time() result = a %*% b toc = Sys.time() cat(\u0026#34;R: Base matrix multiplication version: \u0026#34;, round(1000*(toc-tic), 3), \u0026#34;ms\\n\u0026#34;) R: Base matrix multiplication version: 32.981 ms As expected, this looks to have been optimised reasonably well.\nGeometry library How about a library that provides a dot function? It\u0026rsquo;s compiled code so you\u0026rsquo;d expect it to be fast. I saw this suggestion on StackOverflow.\nlibrary(geometry) tic = Sys.time() result = dot(a, b) toc = Sys.time() cat(\u0026#34;R: geometry dot version: \u0026#34;, round(1000*(toc-tic), 3), \u0026#34;ms\\n\u0026#34;) R: geometry dot version: 386.445 ms This is unexpectedly slow.\nLike python, a lot of R\u0026rsquo;s packages aren\u0026rsquo;t actually written in R they\u0026rsquo;re C, C++ and Fortran to get the speed you want.\nCommon lisp implementations How about common lisp?\nSet up our random vector yet again. It\u0026rsquo;s lisp, so let\u0026rsquo;s just use a list.\n(defun randvect (length) \u0026#34;A simple list (length LENTH) of random numbers [0,1)\u0026#34; (loop for i below length collect (random 1.0))) (defparameter n 10000000) (defparameter a (randvect n)) (defparameter b (randvect n)) Now, let\u0026rsquo;s use some of the power of common lisp and write a macro to make generating the timing functions easier. If that sentence doesn\u0026rsquo;t make sense, this is just a quick way to duplicate the same code across all of my timing functions.\n(defmacro mytime (name description \u0026amp;body body) \u0026#34;Create a function called NAME to get timing when running BODY\u0026#34; `(defun ,name () (let ((tic) (toc)) (setf tic (get-internal-real-time)) ,@body (setf toc (get-internal-real-time)) (format t \u0026#34;lisp: ~a version: ~fms~\u0026amp;\u0026#34; ,description (/ (- toc tic) (/ internal-time-units-per-second 1000)))))) Na√Øve loop Let\u0026rsquo;s try two different looping approaches.\n v1 One of the simplest data types in lisp is the list, it\u0026rsquo;s not a numerical type like in other languages, it\u0026rsquo;s just a linked list of elements\u0026hellip; v2 Let\u0026rsquo;s test an array object, this would perhaps be preferable?   (mytime naive-dot-v1 \u0026#34;naive loop v1\u0026#34; (loop for i in a for j in b sum (* i j))) ;; Let\u0026#39;s make our lists arrays (defparameter aa (make-array (list (length a)) :initial-contents a)) (defparameter ab (make-array (list (length b)) :initial-contents b)) (mytime na√Øve-dot-v2 \u0026#34;na√Øve loop v2\u0026#34; (loop for i below (length aa) sum (* (aref aa i) (aref ab i)))) (naive-dot-v1) (na√Øve-dot-v2) lisp: naive loop v1 version: 163.385ms lisp: na√Øve loop v2 version: 270.050ms Slower than the best python and R implementations, but not bad for a first pass approach for a non-numerical language.\nMagicl library We can optimise pure lisp, to make it fast\u0026hellip;\n(defparameter ma (magicl:from-list a (list n))) (defparameter mb (magicl:from-list b (list n))) (mytime magicl-dot \u0026#34;magicl pure lisp\u0026#34; (magicl:dot ma mb)) (magicl-dot) lisp: magicl pure lisp version: 11.042ms Ever so slightly slower than the NumPy version (\u0026lt; 1 ms), but not bad at all for pure lisp.\nSo, what does \u0026ldquo;optimised\u0026rdquo; pure lisp look like? Well, that\u0026rsquo;s for another write up on Making (pure) lisp functions faster . I\u0026rsquo;ve put quotes around optimised as this isn\u0026rsquo;t a fancy algorithm, it\u0026rsquo;s simply putting variable type hints in the code. The implementation I\u0026rsquo;ll discuss is a little bit of a cheat compared to MAGICL; I haven\u0026rsquo;t generalised it to work for complex numbers - unlike the MAGICL implementation.\nWhat I will do in this post is share the result\u0026hellip;\nlisp: array-dot-lisp version: 10.576ms  Python vs. R vs. lisp - timing What does the following table show us? Python (NumPy), R and common lisp can all produce code that is comparably fast, but in each case you need to think a little bit about your problem set and choose the right approach.\nThe other take-away that I think is important is that (for my use case!) it appears to take considerably less effort and development skill - and is less bug-prone - to take a rapid prototype in lisp and convert it to a fast, production ready implementation than it would in python and R.\n   Language Implementation Time (ms) Rel. to numpy     lisp Pure lisp 10.576 0.9   Python Numpy 11.154 1.0   lisp Magicl pure lisp 11.042 1.0   R Matrix multiplication 32.981 3.0   lisp Na√Øve loop (v1) 163.385 14.6   lisp Na√Øve loop (v2) 270.050 24.2   R Geometry library 386.445 34.6   R Na√Øve loop 533.698 47.8   R Sum element product 1599.384 143.4   Python Na√Øve loop 3632.499 325.7      The computer was a Early 2015 MacBook Air, 2.2 GHz Dual-Core Intel Core i7 with 8 GB of memory.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n This wasn\u0026rsquo;t intended as a pun, but I\u0026rsquo;ll take it!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://stewart123579.github.io/blog/posts/code/calculating-a-dot-product/","summary":"You can get high speed, numerical calculation output without having to resort to bug-prone, highly tuned and optimised, unreadable code.","title":"Calculating a DOT product"},{"content":"I have simple rules for meetings.\n Meeting or an email/instant message? Attending meetings is NOT work. You attend meetings to be involved in a discussion. If you don\u0026rsquo;t need to say anything, or write notes, then you probably shouldn\u0026rsquo;t be there.\nIf you really must invite everyone, differentiate between required and optional invitees so the group knows who is a decision maker and who is there to observe.\nTry to only invite the people who need to be there. Share minutes, packs, etc. with interested parties.\nNo agenda? Don\u0026rsquo;t attend Show some respect for the people you are inviting to a meeting - let them know what the meeting is about by using an agenda.\nBe prescriptive.\nWhat does this agenda even mean?\n Please join the XYZ team for a monthly connection session where we will cover all things ABC and XYZ.\n Are we talking business strategy, or what biscuits we should be buying? If I have a conflicting commitment how can I assess which one to attend?\nWhat about this meeting invitation I received:\n Title: Stewart \u0026amp; XYZ - Data\nAgenda: Sorry to keep changing the date\n It was clearly a little important to the person, they kept changing the date - clearly not very important as they let other meetings book over the top of an existing one - but why do I care about it? What do I need to do?\nCheck my calendar Again, this is about respect. Check my calendar. Try to find a free slot. Don\u0026rsquo;t just book the first time that works for you.\nPeople are reasonable, if you can\u0026rsquo;t find a slot that works, reach out to the person and explain your difficulty. Most people will suggest a time or reschedule things.\nPre-reading? Equivalently, don\u0026rsquo;t assume people have hours of free time to read your pack before attending a meeting.\nI rather like the Amazon approach to meetings. Most meetings won\u0026rsquo;t follow this approach. However, here\u0026rsquo;s a small step in the right direction:\n If there is something important for people to read and digest, give them time in your meeting. That way you will know everyone has the same knowledge when it comes to contributing.\n Timing Start your meeting on time. Finish it early. A number of tools now let you default to 20/45 minute meetings rather than the full 30/60 minutes.\nThis is not a new concept, but sadly it needs reinforcing.\nMinutes and actions Get someone to take minutes. Understand the point of taking minutes - it\u0026rsquo;s not to capture what everyone said, it\u0026rsquo;s to capture the consensus.\nCapture action items. If there are no actions that are coming from the meeting then you should have just sent an informative message.\nSend the minutes and actions to attendees and interested parties.\nReality check Like with most things in life, it\u0026rsquo;s never that simple.\nMy teams know that I will support them by declining (with a polite explanation) meetings that don\u0026rsquo;t have an agenda. They also know there are exceptions. It\u0026rsquo;s about being reasonable - a critical meeting; if anyone above them in the organisational structure: i.e. me (I occasionally break my own rules), the CEO, (actually any of the C-Suite); others of their choosing - organises a meeting without an agenda, they need to attend.\nWhen I do it, they\u0026rsquo;re encouraged to poke the bear and remind me to send an agenda.\n","permalink":"https://stewart123579.github.io/blog/posts/meetings-and-agendas/","summary":"\u003cp\u003eI have simple rules for meetings.\u003c/p\u003e","title":"Meetings and agendas"},{"content":"I was doing some mentoring this past weekend and staff issues came up - as they always do.\nI asked about 1:1s and I realised that this person was being a manager, rather than a leader. We started talking and I thought I would share some of the insights that I got from our conversation.\n Rules were meant to be broken Do what works for you and your staff. Learn from them. Learn from yourself.\nTreat your staff the way you want to be treated Look at your best and worst experiences. Do more of the good and less of the bad. Be brutally honest with yourself. Was it a bad experience because it was a painful, but useful lesson, or was your manager just bad at their job?\n1:1s aren\u0026rsquo;t a nice to have - they are required, at least for you to offer them If you\u0026rsquo;re not having regular 1:1s with your staff, start as soon as you can. Expect the same of any people leaders reporting to you.\nSchedule enough time When I have a reasonable sized team I book a 30 min slot each fortnight (that\u0026rsquo;s every two weeks for our American friends!) with my staff. I then block out the next 30 minutes so they don\u0026rsquo;t feel rushed. Yes, that is 1 hour for each of your direct reports.\nMake time for people who aren\u0026rsquo;t your direct reports. Some people call them \u0026ldquo;Office hours\u0026rdquo;, whatever you call it, schedule the time and then make time for your people.\nThe times are sacrosanct. Don\u0026rsquo;t reschedule on your staff. This is one of the most important rules. You are making yourself available for your staff and showing them that they are important. Don\u0026rsquo;t accept conflicting meetings. Set this rule early and stick to it and your colleagues will understand. If your staff needs to reschedule, be as flexible as you can. Sometimes you will have to reschedule, apologies, explain and most of time time they will understand.\nThis is not a management meeting, this is their time Another important rule. If you are a people leader you should know on what your staff are working. 1:1s are NOT yet-another work meeting.\nThe 1:1 is for your staff to discuss what is important to them. I\u0026rsquo;ve had staff cry, I\u0026rsquo;ve had staff come out, discuss mental health issues, upcoming sports events, ask me what I thought about business strategy, discuss job offers from competitors. It\u0026rsquo;s all on the table. Don\u0026rsquo;t drive the meeting. Let your staff be comfortable. It might take some time, but trust them.\n1:1s are confidential What you discuss in the 1:1 is between you and the staff member. You have to work with this person for a third of your work week. They need to be able to vent about other people at work. You might listen. You might have coping strategies. You don\u0026rsquo;t, EVER, use this against them.\n1:1s are good for feedback As in the point above, as 1:1s are confidential, you can use them for constructive feedback. Help the person grow in their role. If you want to discuss something that wasn\u0026rsquo;t right, don\u0026rsquo;t blame. Discuss what you saw, how it impacted others and then try to get the person to discuss their actions. Talking objectively allows us to see our actions with a cool head.\nTake feedback Ask each of your staff if the format is working for them, and what they would change. I had one staff member that we went for a walk and a coffee, another just wanted to be in the office, get the meeting done and then back to the day. Some like meetings early in the day, some like them later. Some want shorter meetings (keep the full hour blocked - you might even get some time for yourself!). Work with them.\n","permalink":"https://stewart123579.github.io/blog/posts/1-1s-as-a-people-leader/","summary":"\u003cp\u003eI was doing some mentoring this past weekend and staff issues came up - as they\nalways do.\u003c/p\u003e","title":"1:1s as a people leader"},{"content":"Here\u0026rsquo;s a fun observation.\nHow quickly can you find a number between \\(27/97\\) and \\(27/98\\)?\nWithout using a calculator?\n For any two rational numbers1 you can always find another rational number that lies between them by dividing the sum of their numerators by the sum of their denominators.\nHuh? For numbers \\(\\frac{a}{b}\\) and \\(\\frac{c}{d}\\) then \\((a + c) / (b + d)\\) always lies between them.\nIn our case: \\((27 + 27) / (97 + 98) = 54 / 195\\)\n27 / 97 = 0.2783505 54 / 195 = 0.2769231 \u0026lt;-- 27 / 98 = 0.2755102 Why do I care? I was talking to my team at one point and we were making a list of priorities.\nWe came up with the first couple: 1, 2, 3, \u0026hellip; Then came the questions.\nWhat about X? Well, that sits between 1 and 2. Let\u0026rsquo;s call it 1.5.\nWhat about Y? That sits between 1 and 1.5, so let\u0026rsquo;s call it 4/3 (1/1 + 3/2 = 4/3) ü§®\nWhat about Z? That sits between 4/3 and 1.5 so let\u0026rsquo;s call it 7/5 (4/3 + 3/2 = 7/5) ü§®ü§®\nIt then became a bit of a game, testing out my mental arithmetic. They won, I made a mistake, but the underlying algorithm kept working.\nProof(-ish) Define \\(a, b, c, d \\in \\mathbb{Z}\\) and assume without loss of generality\n\\begin{align} \\frac{a}{b} \u0026amp;\\leq \\frac{c}{d} \\nonumber\\\\ \\nonumber\\\\ \\label{eq:order} ad \u0026amp;\\leq bc \\end{align}\n(I\u0026rsquo;ll leave it to you to verify the following still holds when \\(b\\) and/or \\(d\\) are negative.)\nIf we add \\(cd\\) to both sides of Eq. \\ref{eq:order} we get\n\\begin{align} ad + cd \u0026amp;\\leq bc + cd \\nonumber\\\\ d(a + c) \u0026amp;\\leq c(b + d) \\nonumber\\\\ \\nonumber\\\\ \\label{eq:cd} \\frac{a + c}{b + d} \u0026amp;\\leq \\frac{c}{d} \\end{align}\nEquivalently, if we add \\(ab\\) to both sides of Eq. \\ref{eq:order} we find\n\\begin{align} ad + ab \u0026amp;\\leq bc + ab \\nonumber\\\\ a(b + d) \u0026amp;\\leq b(a + c) \\nonumber\\\\ \\nonumber\\\\ \\label{eq:ab} \\frac{a}{b} \u0026amp;\\leq \\frac{a + c}{b + d} \\end{align}\nUsing Eqs. \\ref{eq:cd} and \\ref{eq:ab} we get to our desired result\n\\begin{equation} \\frac{a}{b} \\leq \\frac{a + c}{b + d} \\leq \\frac{c}{d} \\end{equation}\n  A rational number is a real number that can be expressed as the ratio of two integers. Some examples: \\(1 = \\frac{1}{1}\\), \\(\\frac{22}{7}\\), \\(0.5 = \\frac{1}{2}\\), but something like \\(\\pi\\) is irrational and can\u0026rsquo;t be expressed as a fraction.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://stewart123579.github.io/blog/posts/quickly-find-a-number-between-two-others/","summary":"How quickly can you find a number between 27/97 and 27/98? Without using a calculator?","title":"Quickly find a number between two others"},{"content":"Here\u0026rsquo;s how to remove variables and functions from an image:\n(makunbound \u0026#39;variable) (fmakunbound \u0026#39;function) So, for example:\n(defvar foo 42) (defun bar () (print \u0026#34;Hello world!\u0026#34;)) (boundp \u0026#39;foo) ;; T (fboundp \u0026#39;bar) ;; T (makunbound \u0026#39;foo) (fmakunbound \u0026#39;bar) (boundp \u0026#39;foo) ;; nil (fboundp \u0026#39;bar) ;; nil Read on to find out why I prefer the lisp approach over most other languages.\nWhat does this look like in other languages? In interpreted languages, like python and R there is the concept of removing or deleting a variable or function.\nIn python you del variable, in R you rm(variable):\nfoo = 5 foo Naturally results in\n5 Now we delete the variable:\ndel foo # Delete foo foo # Traceback (most recent call last): # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; # NameError: name \u0026#39;foo\u0026#39; is not defined Why does common lisp appear to make it more complicated? Why do we use makunbound and fmakunbound, etc., in common lisp?\n(The following is lightly rewritten and sourced from Peter Norvig\u0026rsquo;s Paradigms of Artificial Intelligence Programming)\n‚Ä¶because common Lisp has at least seven name spaces. The two we think of most often are\n Functions and Macros Variables  Python, R, Scheme, etc. conflate these two name spaces, but Common Lisp keeps them separate, so that in a function application like (f) the function/macro name space is consulted for the value of f, but in (+ f), f is treated as a variable name.\nSpecial variables form a distinct name space from lexical variables So the f in (+ f) is treated as either a special or lexical variable, depending on if there is an applicable special declaration. Data types Even if f is defined as a function and/or a variable, it can also be defined as a data type with defstruct, deftype, or defclass. Labels for go statements within a tagbody Block names for return-from statements within a block Symbols inside a quoted expression are treated as constants, and thus form name space These symbols are often used as keys in user-defined tables, and in a sense each such table defines a new name space. One example is the tag name space, used by catch and throw. Another is the package name space.  Just because you can do something, doesn\u0026rsquo;t mean you should  It is a good idea to limit each symbol to only one name space. Common Lisp will not be confused if a symbol is used in multiple ways, but the poor human reader probably will be.\n Peter Norvig, Paradigms of Artificial Intelligence Programming   ü§£\nWhy do I like the lisp approach? It cuts down on errors.\nWhen collaborating it is easy to clash in your namespaces. You might define the variable two_pi, I might want to define two_pi as a function. My code runs, I merge it. Your code runs, you merge it. We didn\u0026rsquo;t have appropriate testing‚Ä¶ üí£üí•\nHere\u0026rsquo;s a contrived example, presented in three different programming languages: R, python and (common) lisp.\nHere I define a variable two_pi to be twice the value of \\( \\pi \\), then I define a function to calculate the circumference of a circle and then I define a function (also) called two_pi. Let\u0026rsquo;s see what happens‚Ä¶\nIn R two_pi \u0026lt;- 2 * pi circumference \u0026lt;- function(r) { cat(\u0026#34;R: The circumference is \u0026#34;, (two_pi * r), \u0026#34;\\n\u0026#34;) } # We all know pi is actually 3 two_pi \u0026lt;- function() { return(6); } circumference(1) In this case R redefines what is meant by two_pi and the circumference function fails. Why? Because you need to call functions: two_pi()\nError in two_pi * r : non-numeric argument to binary operator In python import math two_pi = 2 * pi def circumference(r): print(f\u0026#34;python: The circumference is {two_pi * r}\u0026#34;) # We all know pi is actually 3 def two_pi(): return 6 circumference(1) Python also redefines what is meant by two_pi and the circumference function fails.\nTraceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 2, in circumference TypeError: unsupported operand type(s) for *: \u0026#39;function\u0026#39; and \u0026#39;int\u0026#39; In lisp (setf two_pi (* 2 pi)) (defun circumference (r) (format t \u0026#34;cl: The circumference is ~a~\u0026amp;\u0026#34; (* two_pi r))) ;; We all know pi is actually only 3. (defun two_pi () 6) (circumference 1) Common lisp works, because it keeps functions and variables in difference namespaces and knows which one to call at which point.\ncl: The circumference is 6.283185307179586d0 ","permalink":"https://stewart123579.github.io/blog/posts/clues/removing-functions-and-variables-in-lisp/","summary":"How to remove definitions and why the lisp namespaces are preferable to other languages' approaches.","title":"Removing functions and variables in lisp"},{"content":"I wanted to list the categories of a blog post, but couldn\u0026rsquo;t find a simple solution.\ntl;dr The snippet in orgmode is simply\n@@hugo:{{\u0026lt;categories-list \u0026gt;}}@@ The shortcode in the file layouts/shortcodes/categories-list.html is\n\u0026lt;!-- Returns an UL (but still ordered) list of categories of the calling page --\u0026gt; {{ $BaseURL := .Site.BaseURL }} \u0026lt;ul\u0026gt; {{ $taxo := \u0026#34;categories\u0026#34; }} \u0026lt;!-- Loop over all categories --\u0026gt; {{range $p := ($.Site.GetPage \u0026#34;taxonomyTerm\u0026#34; $taxo).Pages }} \u0026lt;!-- Loop over all categories for this page --\u0026gt; {{ range $page_category := $.Page.Params.categories }} {{ $wanted_category_link := (printf \u0026#34;%s%s/%s/\u0026#34; $BaseURL $taxo (lower $page_category)) }} \u0026lt;!-- Check to see if the links match --\u0026gt; {{ if in $wanted_category_link $p.Permalink }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{$p.Permalink}}\u0026#34;\u0026gt;{{$p.Title}}\u0026lt;/a\u0026gt;{{if $p.Summary}} \u0026amp;mdash; {{$p.Summary}}{{end}}\u0026lt;/li\u0026gt; {{ end }} {{ end }} {{ end }} \u0026lt;/ul\u0026gt; What is the result? Well, this page is part of the following categories:\n code Tutorials \u0026mdash; A list of things that I forget how to do and I search for, repeatedly.  Caveat emptor My first attempt at this didn\u0026rsquo;t have the .Site.BaseURL reference and I was using $p.RelPermalink rather than $p.Permalink. The code worked for a local test, but didn\u0026rsquo;t work when I deployed to GitHub.\nThe reason was that my URL on GitHub has a trailing /blog where my local test URL didn\u0026rsquo;t and the URL string I was creating missed the /blog when I deployed it.\nThat was a useful lesson.\n","permalink":"https://stewart123579.github.io/blog/posts/code/listing-page-categories-in-hugo/","summary":"\u003cp\u003eI wanted to list the categories of a blog post, but couldn\u0026rsquo;t find a simple solution.\u003c/p\u003e","title":"Listing page categories in Hugo"},{"content":"Use DuckDuckGo to search the Common Lisp Hyperspec with !clhs TERM\nThank you DuckDuckGo! ü•∞\n There is also the L1sp.org document search available with !l1sp\n Search the (at least) 13,565 other DuckDuckGo bang commands!\n","permalink":"https://stewart123579.github.io/blog/posts/code/til-clhs-at-duckduckgo/","summary":"\u003cp\u003eUse DuckDuckGo to search the \u003ca href=\"https://duckduckgo.com/?t=ffab\u0026amp;q=common+lisp+hyperspec\u0026amp;atb=v310-1\u0026amp;ia=web\"\u003eCommon Lisp Hyperspec\u003c/a\u003e with \u003ccode\u003e!clhs TERM\u003c/code\u003e\u003c/p\u003e","title":"TIL: !clhs at DuckDuckGo"},{"content":"I\u0026rsquo;ve been asked what my screensaver means\u0026hellip;\nThis is the message:\n(setq today (find-if \u0026#39;#dayp (cdr your-life))) The code translates to:\n Today is the first day of the rest of your life\n","permalink":"https://stewart123579.github.io/blog/posts/code/my-screensaver/","summary":"\u003cp\u003eI\u0026rsquo;ve been asked what my screensaver means\u0026hellip;\u003c/p\u003e","title":"My screensaver"},{"content":"I wanted to count the number of pages tagged 100daysToOffload but couldn\u0026rsquo;t find a simple solution.\nHere are a couple of options that work. We create a shortcode and in your org file pass the wanted tag to it in the variable tagname, like so:\n@@hugo:{{\u0026lt;tag-count tagname=\u0026#34;MyWantedTag\u0026#34; \u0026gt;}}@@ The shortcode(s) Create a file layouts/shortcodes/tag-count.html and add the code below.\nPreferred approach My preferred approach is to use the existing .Site.Taxonomies variable:\n{{ len (.Site.Taxonomies.tags.Get (lower (.Get \u0026#34;tagname\u0026#34;))) }} What is happening here?\n (.Get \u0026quot;tagname\u0026quot;) Returns the value of the variable tagname; in the above example this would be MyWantedTag (lower ...) Converts the result to lower case. Note that tags are always lower case (.Site.Taxonomies.tags.Get ...) Gets the list of pages that are tagged with the wanted term len ... Returns the length of the list of tagged pages, i.e. the number of pages with the wanted tag  Alternative #1 - filter We can use the range function to loop over all of the tags and their values like this\u0026hellip;\n{{ range $key, $value := .Site.Taxonomies.tags }} {{ if in $key (.Get \u0026#34;tagname\u0026#34;) }} {{ len $value }} {{ end }} {{ end }} Alternative #2 - brute force The final option is based on this post where we loop over all the pages and increment a counter if we find a page with the right tag.\n\u0026lt;!-- (re)set the counter to 0 --\u0026gt; {{ $.Scratch.Set \u0026#34;tagCounter\u0026#34; 0 }} \u0026lt;!-- increment counter if post contains the wanted tag--\u0026gt; {{ range .Site.RegularPages }} {{ if in .Params.tags $tagname }} {{ $.Scratch.Add \u0026#34;tagCounter\u0026#34; 1 }} {{ end }} {{ end }} \u0026lt;!-- Return the result --\u0026gt; {{ $.Scratch.Get \u0026#34;tagCounter\u0026#34; }} ","permalink":"https://stewart123579.github.io/blog/posts/code/counting-tagged-pages-in-hugo/","summary":"\u003cp\u003eI wanted to count the number of pages tagged \u003ccode\u003e100daysToOffload\u003c/code\u003e but couldn\u0026rsquo;t\nfind a simple solution.\u003c/p\u003e","title":"Counting tagged pages in Hugo"},{"content":"Including beautifully rendered equations is easy in Org Mode.\nIt was as simple as surrounding the question by dollar signs: $\\psi (t)$ which appears on my screen as \\(\\psi(t)\\).\nYou can wrap them with \\begin{equation} ... \\end{equation} like\n\\begin{equation} i \\hbar \\frac{\\partial}{\\partial t}\\left|\\psi (t)\\right\\rangle = \\hat{H} \\left|\\psi (t)\\right\\rangle \\end{equation} will produce\n\\begin{equation} i \\hbar \\frac{\\partial}{\\partial t}\\left|\\psi (t)\\right\\rangle = \\hat{H} \\left|\\psi (t)\\right\\rangle \\end{equation}\n Previewing as you write RTFM to understand what is going on, but\n C-c C-x C-l (org-latex-preview) Produce a preview image of the LaTeX fragment at point and overlay it over the source code. If there is no fragment at point, process all fragments in the current entry\u0026mdash;between two headlines. When called with a single prefix argument, clear all images in the current entry. Two prefix arguments produce a preview image for all fragments in the buffer, while three of them clear all the images in that buffer.\n  Automatically displaying equations For standard Org documents (for example Org Roam notes) you should add #+startup: latexpreview at the start of the file.\nFor example, the following note for the Schr√∂dinger equation has the command at line 5:\n1 2 3 4 5 6 7 8 9  :PROPERTIES: :ID: 1238BA43-EBAA-4D44-F54D-BEEF9E636548 :END: #+title: Schr√∂dinger equation #+startup: latexpreview  \\begin{equation} i \\hbar \\frac{\\partial}{\\partial t}\\left|\\psi (t)\\right\\rangle = \\hat{H} \\left|\\psi (t)\\right\\rangle \\end{equation}   For Hugo posts My Hugo posts are created converting org \\(\\to\\) markdown \\(\\to\\) HTML. However, all that is needed is adding line 4 to the properties drawer, as shown below:\n1 2 3 4 5  :PROPERTIES: :EXPORT_FILE_NAME: price-forecasts-comparison :EXPORT_DATE: 2019-01-27T20:43:00+10:00 :export_hugo_custom_front_matter: :math true :END:   However, for Hugo we should be wrapping the equations in \\( ... \\).\n","permalink":"https://stewart123579.github.io/blog/posts/emacs/including-equations-in-my-notes/","summary":"\u003cp\u003eIncluding beautifully rendered equations is easy in Org Mode.\u003c/p\u003e","title":"Including equations in my notes"},{"content":"How do you buy a federal election? Through money laundering, by confusing correlation and causation and mindlessly parroting collective wisdom around housing affordability.\nView the post at LinkedIn, or Vifortech Solutions - Blog.\n","permalink":"https://stewart123579.github.io/blog/posts/money-laundering-buying-elections-and-housing-affordability/","summary":"How do you buy a federal election? Through money laundering, by confusing correlation and causation and mindlessly parroting collective wisdom around housing affordability.\nView the post at LinkedIn, or Vifortech Solutions - Blog.","title":"Money laundering, buying elections and housing affordability"},{"content":"I always forget how to update the list of local projects for Quicklisp.\n(ql:register-local-projects) I think I learned about it from Wimpie Nortje\u0026rsquo;s post.\n","permalink":"https://stewart123579.github.io/blog/posts/clues/quicklisp/update-list-of-local-projects/","summary":"\u003cp\u003eI always forget how to update the list of local projects for Quicklisp.\u003c/p\u003e","title":"Update list of local projects for Quicklisp"},{"content":"Leaders inspire you to follow; their actions make you aspire to be like them.\nManagers tell people what to do. Often they do this though intimidation and fear of losing your job.\n There are many, many, many pages that Google has indexed about Inspiring Leaders, but what does that mean on a more personal level? I feel incredibly fortunate to have experienced a great leader in action. In my view a leader differs from a manager, by leading, not by checking boxes about how they should behave.\n You can tell you\u0026rsquo;re in a meeting with managers rather than leaders because they use words like I. It\u0026rsquo;s especially obvious in a meeting where they may be a manager and one worker presenting results to a broader audience.\nLeaders use I, but to praise. They use words like we when describing their work or, more likely, the name of the team member who did the good work.\n Managers constantly promote themselves to appear successful.\nLeaders are successful through the reflected success of their team - and through the praise their staff give to them.\n Managers promote (and protect) other managers. If you find one in the organisation, keep looking up the reporting line to find the root cause.\nLeaders spread their success - the person they aspire to is probably not even part of your organisation.\n I mentioned how fortunate I was experiencing true leadership. This person encouraged me and others, gave more recognition to us than was honestly due, never claimed our successes as their own and, perhaps most importantly, challenged us to grow and achieve more than we thought we could. Whilst I\u0026rsquo;ve not worked with them for a number of years I still think and talk about their impact and I try to replicate for those with whom I have the pleasure of working.\n","permalink":"https://stewart123579.github.io/blog/posts/leaders-versus-managers/","summary":"\u003cp\u003eLeaders inspire you to follow; their actions make you aspire to be like them.\u003c/p\u003e","title":"Leaders versus managers"},{"content":"Sometimes you just want to see the files that are being ignored by git.\ngit status --ignored  Of course, you could just RTFM.\n","permalink":"https://stewart123579.github.io/blog/posts/code/show-files-ignored-by-git/","summary":"\u003cp\u003eSometimes you just want to see the files that are being ignored by \u003ca href=\"https://git-scm.com/\"\u003egit\u003c/a\u003e.\u003c/p\u003e","title":"Show files ignored by git"},{"content":"Removing untracked files from the working tree is easy with git-clean\nI use this for removing intermediate (i.e. known, ignored) files:\ngit clean -Xf  -X Remove only files ignored by Git -f Force the removal   Of course, you could just RTFM.\n","permalink":"https://stewart123579.github.io/blog/posts/code/delete-files-not-being-tracked-by-git/","summary":"\u003cp\u003eRemoving untracked files from the working tree is easy with \u003ccode\u003egit-clean\u003c/code\u003e\u003c/p\u003e","title":"Delete files not being tracked by git"},{"content":"Removing files you just added and committed to git is easy with git commit --amend\ngit rm --cached \u0026lt;yourfile\u0026gt; git commit --amend git push -f Taken from this answer on StackOverflow.\n","permalink":"https://stewart123579.github.io/blog/posts/code/commit-amend-remove-added/","summary":"\u003cp\u003eRemoving files you just added and committed to git is easy with \u003ccode\u003egit commit --amend\u003c/code\u003e\u003c/p\u003e","title":"Amend git commits to remove added files"},{"content":"Surely Pretentious? Moi? is the greatest two-word joke.\nFrom The Psychiatrist episode of Fawlty Towers.\n","permalink":"https://stewart123579.github.io/blog/posts/pretentious-moi/","summary":"","title":"Pretentious? Moi?"},{"content":"There are various discussions around the conflict between Org Mode and yasnippet and how to fix it.\nThis is how I got them to play nicely together.\n(use-package yasnippet :init (defun yas/org-very-safe-expand () (let ((yas/fallback-behavior \u0026#39;return-nil)) (yas/expand))) :hook ((emacs-lisp-mode . yas-minor-mode) (python-mode . yas-minor-mode) (org-mode . yas-minor-mode) (org-mode . (lambda () (make-variable-buffer-local \u0026#39;yas/trigger-key) (setq yas/trigger-key [tab]) (add-to-list \u0026#39;org-tab-first-hook \u0026#39;yas/org-very-safe-expand) (define-key yas/keymap [tab] \u0026#39;yas/next-field)))) :config (setq-default yas-snippet-dirs `(,(expand-file-name \u0026#34;snippets/\u0026#34; user-emacs-directory))) (yas-reload-all)) GNU Emacs 28.1 Org mode version 9.5.3 YASnippet 0.14.0\n","permalink":"https://stewart123579.github.io/blog/posts/emacs/yasnippet-and-orgmode/","summary":"There are various discussions around the conflict between Org Mode and yasnippet and how to fix it.\nThis is how I got them to play nicely together.\n(use-package yasnippet :init (defun yas/org-very-safe-expand () (let ((yas/fallback-behavior \u0026#39;return-nil)) (yas/expand))) :hook ((emacs-lisp-mode . yas-minor-mode) (python-mode . yas-minor-mode) (org-mode . yas-minor-mode) (org-mode . (lambda () (make-variable-buffer-local \u0026#39;yas/trigger-key) (setq yas/trigger-key [tab]) (add-to-list \u0026#39;org-tab-first-hook \u0026#39;yas/org-very-safe-expand) (define-key yas/keymap [tab] \u0026#39;yas/next-field)))) :config (setq-default yas-snippet-dirs `(,(expand-file-name \u0026#34;snippets/\u0026#34; user-emacs-directory))) (yas-reload-all)) GNU Emacs 28.","title":"Getting yasnippet to work with Org mode"},{"content":"There are two type of lisp coders. Those that love the loop macro and those that don\u0026rsquo;t.\nI\u0026rsquo;m one of the former.\nTake this beautiful construction:\n(loop for item in mylist collect (first item) into known-keys maximize (second item) into big minimize (second item) into small finally (return (values known-keys big small))) Even not knowing what mylist was you could guess that known-keys would be the collection of all the first elements of item, and big and small would be the largest and smallest values in the second part of item.\n If I told you that mylist was a list of items that had two elements, viz.\n((a . 3) (b . 2) (c . 1)) You\u0026rsquo;d be able to guess that the result would be something like\n(a b c) 3 1  loop is easy to read and reflects the true strength of common lisp - DSLs make readable (and performant) code easy.\n","permalink":"https://stewart123579.github.io/blog/posts/clues/loops-in-lisp/","summary":"\u003cp\u003eThere are two type of lisp coders. Those that \u003cstrong\u003elove\u003c/strong\u003e the \u003ccode\u003eloop\u003c/code\u003e macro and those\nthat don\u0026rsquo;t.\u003c/p\u003e","title":"Loops in Lisp"},{"content":"How would you find the .org (or .pdf, .doc, \u0026hellip;) file you created the most recently?\nfind . -type f -iname \\*.org -printf \u0026#34;\\n%AF %AT %p\u0026#34; | sort -r | head If you\u0026rsquo;ve installed the GNU findutils on MacOS from Homebrew you might need to use gfind.\n","permalink":"https://stewart123579.github.io/blog/posts/code/find-most-recently-changed-files-of-a-type/","summary":"\u003cp\u003eHow would you find the \u003ccode\u003e.org\u003c/code\u003e (or \u003ccode\u003e.pdf\u003c/code\u003e, \u003ccode\u003e.doc\u003c/code\u003e, \u0026hellip;) file you created the most\nrecently?\u003c/p\u003e","title":"Find most recently changed files of a type"},{"content":"This is my blog. The design isn\u0026rsquo;t revolutionary.\nIt is just a group of static pages - thanks to the Hugo engine. The theme is PaperMod.\nI write all of my posts (and almost everything else) using Emacs. In particular I use Org Mode, and I\u0026rsquo;ve recently discovered the useful ox-hugo minor mode to export the pages for Hugo.\nMy plan is to replicate all of my other writings here. So you will see links/references to, amongst others, the Vifortech Solutions blog (see the Vifortech category).\nTesting locally I test locally, including looking at drafts with the following command:\nhugo server --buildDrafts --navigateToChanged If I\u0026rsquo;m feeling adventurous and want to test on another machine I\u0026rsquo;ll try something like\nhugo server --buildDrafts --navigateToChanged --baseURL http://$(uname -n) --bind 0.0.0.0 I\u0026rsquo;m faking the baseURL here to be my local hostname, so I can test on mobile for example. If my (or your) hostname doesn\u0026rsquo;t resolve, the command ipconfig getifaddr en0 will give the local IP address.\nThis also opens up the site to everyone on the network, so probably not wise to do this on a public WiFi.\nExport the HTML for public consumption hugo --cleanDestinationDir Depending on how I\u0026rsquo;m working I\u0026rsquo;ll either use magit (by preference) in Emacs or just git on the command line to commit the changes and then push to the wider world.\n","permalink":"https://stewart123579.github.io/blog/posts/my-blog/","summary":"\u003cp\u003eThis is my blog.  The design isn\u0026rsquo;t revolutionary.\u003c/p\u003e","title":"This is my blog"},{"content":"The Mars Rover Tech Challenge (in Lisp!) Part 2 at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/lisp-mars-rover-2/","summary":"The Mars Rover Tech Challenge (in Lisp!) Part 2 at Vifortech Solutions - Blog","title":"The Mars Rover Tech Challenge (in Lisp!) Part 2"},{"content":"The Mars Rover Tech Challenge (in Lisp!) Part 1 at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/lisp-mars-rover/","summary":"The Mars Rover Tech Challenge (in Lisp!) Part 1 at Vifortech Solutions - Blog","title":"The Mars Rover Tech Challenge (in Lisp!) Part 1"},{"content":"Real Estate price forecasts in the media at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/price-forecasts-comparison/","summary":"Real Estate price forecasts in the media at Vifortech Solutions - Blog","title":"Real Estate price forecasts in the media"},{"content":"Fixing Emacs' unknown and untrusted authority TLS error at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/emacs-tls-fix/","summary":"Fixing Emacs' unknown and untrusted authority TLS error at Vifortech Solutions - Blog","title":"Fixing Emacs' unknown and untrusted authority TLS error"},{"content":"The flu as an analogy for risk management at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/flu-risk-management/","summary":"The flu as an analogy for risk management at Vifortech Solutions - Blog","title":"The flu as an analogy for risk management"},{"content":"Real estate as an investment at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/real-estate-as-an-investment/","summary":"Real estate as an investment at Vifortech Solutions - Blog","title":"Real estate as an investment"},{"content":"Disasters and Real Estate at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/disasters-and-real-estate/","summary":"Disasters and Real Estate at Vifortech Solutions - Blog","title":"Disasters and Real Estate"},{"content":"Presenting at the 2017 Q Group Colloquium at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/2017-qgroup-colloquium/","summary":"Presenting at the 2017 Q Group Colloquium at Vifortech Solutions - Blog","title":"Presenting at the 2017 Q Group Colloquium"},{"content":"Honesty in forecasting at Vifortech Solutions - Blog\n","permalink":"https://stewart123579.github.io/blog/posts/honesty-in-forecasting/","summary":"Honesty in forecasting at Vifortech Solutions - Blog","title":"Honesty in forecasting"}]