<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Making (pure) lisp functions faster | SVW Thunk'd</title><meta name=keywords content="lisp,100daysToOffload,ai-ml"><meta name=description content="What does optimised pure lisp look like?"><meta name=author content="Stewart V. Wright"><link rel=canonical href=https://stewart123579.github.io/blog/posts/code/making-pure-lisp-functions-faster/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://stewart123579.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://stewart123579.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://stewart123579.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://stewart123579.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://stewart123579.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=canonical href=https://stewart123579.github.io/blog/posts/code/making-pure-lisp-functions-faster/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/lightgallery/2.4.0/css/lightgallery-bundle.min.css integrity="sha512-91yJwfiGTCo9TM74ZzlAIAN4Eh5EWHpQJUfvo/XhpH6lzQtiRFkFRW1W+JSg4ch4XW3/xzh+dY4TOw/ILpavQA==" crossorigin=anonymous referrerpolicy=no-referrer><style>.flex-container{display:flex;flex-flow:row wrap;justify-content:space-around}</style><meta property="og:title" content="Making (pure) lisp functions faster"><meta property="og:description" content="What does optimised pure lisp look like?"><meta property="og:type" content="article"><meta property="og:url" content="https://stewart123579.github.io/blog/posts/code/making-pure-lisp-functions-faster/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-24T00:00:00+10:00"><meta property="article:modified_time" content="2022-06-24T00:00:00+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Making (pure) lisp functions faster"><meta name=twitter:description content="What does optimised pure lisp look like?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://stewart123579.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Code","item":"https://stewart123579.github.io/blog/posts/code/"},{"@type":"ListItem","position":3,"name":"Making (pure) lisp functions faster","item":"https://stewart123579.github.io/blog/posts/code/making-pure-lisp-functions-faster/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Making (pure) lisp functions faster","name":"Making (pure) lisp functions faster","description":"What does optimised pure lisp look like?\n","keywords":["lisp","100daysToOffload","ai-ml"],"articleBody":"What does optimised pure lisp look like?\nIn my previous post on Calculating a DOT product I mentioned making a fast pure lisp implementation of the dot product function. Let’s dig into that.\nLet’s see if we can compete with the magicl code, or the highly optimised C code in numpy. My goals to explore are twofold:\nMake pure lisp code comparable in speed to the R and python best cases Make the code readable, we’re not going to use fancy tricks or algorithms, or reduce readability (too highly optimised code leads to hard to identify bugs and difficulties maintaining!) This post is heavily motivated by the magicl dot product code and it appears in the following categories: AI / ML in common lisp — Implementing AI and Machine Learning tools in common lisp.\ncode Initial setup As we did previously, let’s create two lists, each being 10 million random numbers between 0 and 1.\n(defun randvect (length) \"A simple list (length LENTH) of random numbers [0,1)\" (loop for i below length collect (random 1.0))) (defvar n 10000000 \"The length of our test data\") (defvar a (randvect n) \"A list, length N, of random numbers\") (defvar b (randvect n) \"Another list, length N, of random numbers\") Thinking about how we should store our data lists versus arrays lists aren’t ideal for storing vectors, lookup speed grows with length, whilst arrays have a constant time. This is important when building models, where the list/array might be 10 million (or more) observations of our experiment (defparameter array-a (make-array (list (length a)) :initial-contents a)) (defparameter array-b (make-array (list (length b)) :initial-contents b)) Previous version of the code This is the code I had for naïve-dot-v2 (which I’m calling v1 here)\n(loop for i below (length array-a) sum (* (aref array-a i) (aref array-b i))) v1 - 270.0504ms Let’s turn this into a function so we can optimise it…\n(defun dot-v2 (array1 array2) (loop for i below (length array1) sum (* (aref array1 i) (aref array2 i)))) v2 - 234.21423ms Adding a check Before we optimise the code, we should add a check to make sure the arrays are the same size:\n(defun dot-v3 (array1 array2) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 sum (* (aref array1 i) (aref array2 i))))) v3 - 220.24509ms I’ve created two new variables size1 and size2 and assert that they are equal.\nI’m not really sure why this was faster, it was probably a function of whatever else was (or wasn’t) running on my machine at the time, but it’s not really material.\nI want speed! Let’s be clear - we want to optimise for SPEED, so be explicit in line 2.\n1 2 3 4 5 6 7 (defun dot-v4 (array1 array2) (declare (optimize speed)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 sum (* (aref array1 i) (aref array2 i))))) v4 - 222.48372ms No improvement!\nWhy? We haven’t given any hints to the how the compiler/interpreter can improve things. Let’s remove the optimise command and add some type hints.\nAdding data type information Now let’s use lisp’s gradual typing features. I’m planning to write about this in another post (and I’ll update this one to point to it).\ndata type Python and R are making assumptions on the data we’re storing, they’re both assuming floating point numbers. How do I this in lisp? Easily. We just add :element-type 'single-float to the make-array command. This is exactly comparable to the dtype=float32 flag you’d use in python’s NumPy/TensorFlow/etc.\n(defparameter array-a-v2 (make-array (list (length a)) :initial-contents a :element-type 'single-float)) (defparameter array-b-v2 (make-array (list (length b)) :initial-contents b :element-type 'single-float)) Gradual typing is where we can define the type of data in a particular function - but we don’t have to everywhere. (Most) Other languages have an all-or-nothing approach, but lisp allows you to choose.\nBelow, in line 2, we simply declare that the type of the inputs array1 and array2 are simple-array single-float (*), which means:\nsimple-array just take this as it reads - a simple array - or dig into the CLHS for details single-float elements are floating point numbers (as opposed to, say double precision or complex numbers) (*) indicates this is a single dimensional array, i.e. vector, of unknown size 1 2 3 4 5 6 7 (defun dot-v5 (array1 array2) (declare (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 sum (* (aref array1 i) (aref array2 i))))) v5 - 120.991104ms We’ve almost halved the run time - because the multiplication on line 7 now can be simplified to only handle single-float arguments rather than a generic operation that works for integers, single and double floats, ratios, complex numbers, …\nAdding type information to the loop: the accumulator We have now optimised our multiplication to work for out single-float arguments, but the accumulator (i.e. the sum part) in the loop function doesn’t know the type of it’s arguments. However, we do. The sum of two values of type single-float is another single-float. In line 7 we use that information:\n1 2 3 4 5 6 7 8 9 (defun dot-v6 (array1 array2) (declare (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 with s of-type single-float = 0.0 do (incf s (* (aref array1 i) (aref array2 i))) finally (return s)))) We’ve also had to add lines 8 and 9 to replicate what the sum keyword is providing in the loop.\nThe results were staggering when I first saw them.\nv6 - 11.116839ms We took an order of magnitude off the run-time and are now in the realms of the NumPy - hand tuned, optimised and mostly unreadable, C.\nOptimise for speed, again Again, let’s be explicit that we want SPEED.\n(defun dot-v7 (array1 array2) (declare (optimize speed) (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i below size1 with s of-type single-float = 0.0 do (incf s (* (aref array1 i) (aref array2 i))) finally (return s)))) The lisp implementation I’m using (SBCL) is already a high performance Common Lisp compiler, so there’s not much to be squeezed out here.\nv7 - 10.600901ms Adding type information to the loop: array index We can help the compiler out a little more by letting it know that the loop variable i is for indexing arrays:\n(defun dot-v8 (array1 array2) (declare (optimize speed) (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i of-type alexandria:array-index below size1 with s of-type single-float = 0.0 do (incf s (* (aref array1 i) (aref array2 i))) finally (return s)))) With this we can squeeze out a little more speed, but to be honest this result fluctuated depending on what else my computer was doing.\nv8 - 10.57616ms Almost the end At this point I would look into defgeneric where I can define multiple dot functions each optimised for different inputs, so double-float, complex-float, etc. This is similar to overloading in other languages. However, I’ll leave that for another day.\nNow, if this was a language benchmark post, I’d stop here. However, I want to use this dot function in a practical use case. That’s what I do in some following articles where I build a AI/ML model (a neural network in fact) in lisp.\nFinally Let’s compare the initial function and the optimised one:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (defun final-dot (array1 array2) (declare (optimize speed) (type (simple-array single-float (*)) array1 array2)) (let ((size1 (length array1)) (size2 (length array2))) (assert (cl:= size1 size2)) (loop for i of-type alexandria:array-index below size1 with s of-type single-float = 0.0 do (incf s (* (aref array1 i) (aref array2 i))) finally (return s)))) (defun initial-dot (array1 array2) (loop for i below (length array1) sum (* (aref array1 i) (aref array2 i)))) Line 1 Defining the function [Same as line 13] Line 2 Tell the compiler we want fast code Line 3 Tell the compiler the arguments are single-float Lines 4 – 6 Check to see that the vectors are the same length Line 7 Create our iterating variable [Effectively, same as line 14] Line 8 Tell the compiler that our accumulator variable s is a single-float Lines 9 \u0026 10 Sum up the product of the array elements [Same as line 15] Effectively, by adding lines 3 and 8 we have taken the time to calculate the dot product from 270ms down to 10.576ms, speeding it up by more than 25 times and ending with a run time that is comparable to Numpy (11.154ms - previously ).\nAn aside… Why did I say the lines 9 \u0026 10 are the same as line 15?\nThe loop macro in common lisp is incredibly versatile.\nThe code generated by these two loops is virtually identical\n;; Loop version 1 (loop for i below 5 sum i) ;; Loop version 2 (loop for i below 5 with s = 0 do (incf s i) finally (return s)) The only real difference is the variable #:LOOP-SUM-708 in this first code block acting as a proxy for S in the second loop.\nThis is the expansion of the first loop (using (macroexpand-1 '(loop for i below 5 sum i))):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (block nil (let ((i 0)) (declare (ignorable i) (type (and number real) i)) (;; some sbcl specific defintions of the loop ;; variable #:loop-sum-708 (tagbody sb-loop::next-loop (when (\u003e= i '5) (go sb-loop::end-loop)) (setq #:loop-sum-708 (+ #:loop-sum-708 i)) (sb-loop::loop-desetq i (1+ i)) (go sb-loop::next-loop) sb-loop::end-loop (return-from nil #:loop-sum-708))))) The expansion of the second loop, where lines 5 \u0026 6 (defining the variable S) are the only material differences.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (block nil (let ((i 0)) (declare (ignorable i) (type (and number real) i)) (let ((s 0)) (declare (ignorable s)) (tagbody sb-loop::next-loop (when (\u003e= i '5) (go sb-loop::end-loop)) (incf s i) (sb-loop::loop-desetq i (1+ i)) (go sb-loop::next-loop) sb-loop::end-loop (return s))))) In case you were wondering about the (incf s i) in line 10\n(macroexpand-1 '(incf s i)) (setq s (+ i s)) which is the same form as line 10 in the first expansion.\nAren’t lisp macros amazing!?\n","wordCount":"1756","inLanguage":"en","datePublished":"2022-06-24T00:00:00+10:00","dateModified":"2022-06-24T00:00:00+10:00","author":[{"@type":"Person","name":"Stewart V. Wright"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://stewart123579.github.io/blog/posts/code/making-pure-lisp-functions-faster/"},"publisher":{"@type":"Organization","name":"SVW Thunk'd","logo":{"@type":"ImageObject","url":"https://stewart123579.github.io/blog/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://stewart123579.github.io/blog/ accesskey=h title="SVW Thunk'd (Alt + H)">SVW Thunk'd</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://stewart123579.github.io/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://stewart123579.github.io/blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://stewart123579.github.io/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://stewart123579.github.io/blog/archives/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://stewart123579.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://stewart123579.github.io/blog/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://stewart123579.github.io/blog/posts/code/>Code</a></div><h1 class=post-title>Making (pure) lisp functions faster</h1><div class=post-meta><span title='2022-06-24 00:00:00 +1000 AEST'>June 24, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Stewart V. Wright</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#initial-setup aria-label="Initial setup">Initial setup</a></li><li><a href=#thinking-about-how-we-should-store-our-data aria-label="Thinking about how we should store our data">Thinking about how we should store our data</a></li><li><a href=#previous-version-of-the-code aria-label="Previous version of the code">Previous version of the code</a></li><li><a href=#adding-a-check aria-label="Adding a check">Adding a check</a></li><li><a href=#i-want-speed aria-label="I want speed!">I want speed!</a></li><li><a href=#adding-data-type-information aria-label="Adding data type information">Adding data type information</a></li><li><a href=#adding-type-information-to-the-loop-the-accumulator aria-label="Adding type information to the loop: the accumulator">Adding type information to the loop: the accumulator</a></li><li><a href=#optimise-for-speed-again aria-label="Optimise for speed, again">Optimise for speed, again</a></li><li><a href=#adding-type-information-to-the-loop-array-index aria-label="Adding type information to the loop: array index">Adding type information to the loop: array index</a></li><li><a href=#almost-the-end aria-label="Almost the end">Almost the end</a></li><li><a href=#finally aria-label=Finally>Finally</a><ul><li><a href=#an-aside-dot-dot-dot aria-label="An aside&amp;hellip;">An aside&mldr;</a></li></ul></li></ul></div></details></div><div class=post-content><p>What does optimised pure lisp look like?</p><p>In my previous post on <a href=/blog/posts/code/calculating-a-dot-product/>Calculating a DOT product</a> I mentioned making a fast pure lisp
implementation of the dot product function. Let&rsquo;s dig into that.</p><p>Let&rsquo;s see if we can compete with the <code>magicl</code> code, or the highly optimised C
code in <code>numpy</code>. My goals to explore are twofold:</p><ol><li>Make <strong>pure lisp code</strong> comparable in speed to the R and python best cases</li><li>Make the <strong>code readable</strong>, we&rsquo;re not going to use fancy tricks or algorithms,
or reduce readability (too highly optimised code leads to hard to identify
bugs and difficulties maintaining!)</li></ol><p>This post is heavily motivated by the <a href=https://github.com/quil-lang/magicl/blob/5224101d13dd77ff43df6efb5e188dbcc922fce9/src/high-level/types/specialized-vector.lisp>magicl dot product</a> code and it appears in
the following categories:<ul><li><a href=https://stewart123579.github.io/blog/categories/ai-ml-lisp/>AI / ML in common lisp</a> &mdash;<p>Implementing AI and Machine Learning tools in common lisp.</p></li><li><a href=https://stewart123579.github.io/blog/categories/code/>code</a></li></ul></p><h2 id=initial-setup>Initial setup<a hidden class=anchor aria-hidden=true href=#initial-setup>#</a></h2><p>As we did previously, let&rsquo;s create two lists, each being 10 million random
numbers between 0 and 1.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>randvect</span> (<span style=color:#00a000>length</span>)
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;A simple list (length LENTH) of random numbers [0,1)&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#00a000>length</span> <span style=color:#b8860b>collect</span> (<span style=color:#00a000>random</span> <span style=color:#666>1.0</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a2f>defvar</span> <span style=color:#b8860b>n</span> <span style=color:#666>10000000</span>      <span style=color:#b44>&#34;The length of our test data&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#a2f>defvar</span> <span style=color:#b8860b>a</span> (<span style=color:#b8860b>randvect</span> <span style=color:#b8860b>n</span>)  <span style=color:#b44>&#34;A list, length N, of random numbers&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#a2f>defvar</span> <span style=color:#b8860b>b</span> (<span style=color:#b8860b>randvect</span> <span style=color:#b8860b>n</span>)  <span style=color:#b44>&#34;Another list, length N, of random numbers&#34;</span>)
</span></span></code></pre></div><h2 id=thinking-about-how-we-should-store-our-data>Thinking about how we should store our data<a hidden class=anchor aria-hidden=true href=#thinking-about-how-we-should-store-our-data>#</a></h2><dl><dt>lists versus arrays</dt><dd>lists aren&rsquo;t ideal for storing vectors, lookup speed
grows with length, whilst arrays have a constant time. This is important when
building models, where the list/array might be 10 million (or more)
observations of our experiment</dd></dl><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>array-a</span> (<span style=color:#00a000>make-array</span> (<span style=color:#00f>list</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>a</span>)) <span style=color:#b8860b>:initial-contents</span> <span style=color:#b8860b>a</span>))
</span></span><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>array-b</span> (<span style=color:#00a000>make-array</span> (<span style=color:#00f>list</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>b</span>)) <span style=color:#b8860b>:initial-contents</span> <span style=color:#b8860b>b</span>))
</span></span></code></pre></div><h2 id=previous-version-of-the-code>Previous version of the code<a hidden class=anchor aria-hidden=true href=#previous-version-of-the-code>#</a></h2><p>This is the code I had for <code>naïve-dot-v2</code> (which I&rsquo;m calling <code>v1</code> here)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array-a</span>)
</span></span><span style=display:flex><span>      <span style=color:#b8860b>sum</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array-a</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array-b</span> <span style=color:#b8860b>i</span>)))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v1 - 270.0504ms
</span></span></code></pre></div><p>Let&rsquo;s turn this into a function so we can optimise it&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>dot-v2</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>)
</span></span><span style=display:flex><span>        <span style=color:#b8860b>sum</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>))))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v2 - 234.21423ms
</span></span></code></pre></div><h2 id=adding-a-check>Adding a check<a hidden class=anchor aria-hidden=true href=#adding-a-check>#</a></h2><p>Before we optimise the code, we should add a check to make sure the arrays are
the same size:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>dot-v3</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>size1</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>))
</span></span><span style=display:flex><span>        (<span style=color:#b8860b>size2</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>assert</span> (<span style=color:#b8860b>cl:=</span> <span style=color:#b8860b>size1</span> <span style=color:#b8860b>size2</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#b8860b>size1</span>
</span></span><span style=display:flex><span>          <span style=color:#b8860b>sum</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>)))))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v3 - 220.24509ms
</span></span></code></pre></div><p>I&rsquo;ve created two new variables <code>size1</code> and <code>size2</code> and <code>assert</code> that they are
equal.</p><p>I&rsquo;m not really sure why this was faster, it was probably a function of whatever
else was (or wasn&rsquo;t) running on my machine at the time, but it&rsquo;s not really
material.</p><h2 id=i-want-speed>I want speed!<a hidden class=anchor aria-hidden=true href=#i-want-speed>#</a></h2><p>Let&rsquo;s be clear - we want to optimise for SPEED, so be explicit in line 2.</p><div class=highlight><div style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>dot-v4</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>optimize</span> <span style=color:#b8860b>speed</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>size1</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>))
</span></span><span style=display:flex><span>        (<span style=color:#b8860b>size2</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>assert</span> (<span style=color:#b8860b>cl:=</span> <span style=color:#b8860b>size1</span> <span style=color:#b8860b>size2</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#b8860b>size1</span>
</span></span><span style=display:flex><span>          <span style=color:#b8860b>sum</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>)))))
</span></span></code></pre></td></tr></table></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v4 - 222.48372ms
</span></span></code></pre></div><p>No improvement!</p><p>Why? We haven&rsquo;t given any hints to the how the compiler/interpreter can improve things.
Let&rsquo;s remove the optimise command and add some type hints.</p><h2 id=adding-data-type-information>Adding data type information<a hidden class=anchor aria-hidden=true href=#adding-data-type-information>#</a></h2><p>Now let&rsquo;s use lisp&rsquo;s gradual typing features. I&rsquo;m planning to write about this
in another post (and I&rsquo;ll update this one to point to it).</p><dl><dt>data type</dt><dd>Python and R are making assumptions on the data we&rsquo;re storing,
they&rsquo;re both assuming floating point numbers.</dd></dl><p>How do I this in lisp? Easily. We just add <code>:element-type 'single-float</code> to the
<code>make-array</code> command. This is exactly comparable to the <code>dtype=float32</code> flag
you&rsquo;d use in python&rsquo;s NumPy/TensorFlow/etc.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>array-a-v2</span> (<span style=color:#00a000>make-array</span> (<span style=color:#00f>list</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>a</span>))
</span></span><span style=display:flex><span>                                     <span style=color:#b8860b>:initial-contents</span> <span style=color:#b8860b>a</span>
</span></span><span style=display:flex><span>                                     <span style=color:#b8860b>:element-type</span> <span style=color:#b8860b>&#39;single-float</span>))
</span></span><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>array-b-v2</span> (<span style=color:#00a000>make-array</span> (<span style=color:#00f>list</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>b</span>))
</span></span><span style=display:flex><span>                                     <span style=color:#b8860b>:initial-contents</span> <span style=color:#b8860b>b</span>
</span></span><span style=display:flex><span>                                     <span style=color:#b8860b>:element-type</span> <span style=color:#b8860b>&#39;single-float</span>))
</span></span></code></pre></div><p>Gradual typing is where we can define the type of data in a particular
function - but we don&rsquo;t have to everywhere. (Most) Other languages have an
all-or-nothing approach, but lisp allows you to choose.</p><p>Below, in line 2, we simply <code>declare</code> that the type of the inputs <code>array1</code> and
<code>array2</code> are <code>simple-array single-float (*)</code>, which means:</p><dl><dt><code>simple-array</code></dt><dd>just take this as it reads - a simple array - or dig into
the <a href=http://www.lispworks.com/documentation/HyperSpec/Body/t_smp_ar.htm>CLHS</a> for details</dd><dt><code>single-float</code></dt><dd>elements are floating point numbers (as opposed to, say
double precision or complex numbers)</dd><dt><code>(*)</code></dt><dd>indicates this is a single dimensional array, i.e. vector, of unknown size</dd></dl><div class=highlight><div style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>dot-v5</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>type</span> (<span style=color:#0b0;font-weight:700>simple-array</span> <span style=color:#0b0;font-weight:700>single-float</span> (<span style=color:#00a000>*</span>)) <span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>size1</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>))
</span></span><span style=display:flex><span>        (<span style=color:#b8860b>size2</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>assert</span> (<span style=color:#b8860b>cl:=</span> <span style=color:#b8860b>size1</span> <span style=color:#b8860b>size2</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#b8860b>size1</span>
</span></span><span style=display:flex><span>          <span style=color:#b8860b>sum</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>)))))
</span></span></code></pre></td></tr></table></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v5 - 120.991104ms
</span></span></code></pre></div><p>We&rsquo;ve almost halved the run time - <em>because</em> the multiplication on line 7 now
can be simplified to only handle <code>single-float</code> arguments rather than a generic
operation that works for integers, single and double floats, ratios, complex
numbers, &mldr;</p><h2 id=adding-type-information-to-the-loop-the-accumulator>Adding type information to the loop: the accumulator<a hidden class=anchor aria-hidden=true href=#adding-type-information-to-the-loop-the-accumulator>#</a></h2><p>We have now optimised our multiplication to work for out <code>single-float</code>
arguments, but the accumulator (i.e. the <code>sum</code> part) in the <code>loop</code> function
doesn&rsquo;t know the type of it&rsquo;s arguments. However, we do. The sum of two values
of type <code>single-float</code> is another <code>single-float</code>. In line 7 we use that
information:</p><div class=highlight><div style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>dot-v6</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>type</span> (<span style=color:#0b0;font-weight:700>simple-array</span> <span style=color:#0b0;font-weight:700>single-float</span> (<span style=color:#00a000>*</span>)) <span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>size1</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>))
</span></span><span style=display:flex><span>        (<span style=color:#b8860b>size2</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>assert</span> (<span style=color:#b8860b>cl:=</span> <span style=color:#b8860b>size1</span> <span style=color:#b8860b>size2</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#b8860b>size1</span>
</span></span><span style=display:flex><span>          <span style=color:#b8860b>with</span> <span style=color:#b8860b>s</span> <span style=color:#b8860b>of-type</span> <span style=color:#0b0;font-weight:700>single-float</span> <span style=color:#00a000>=</span> <span style=color:#666>0.0</span>
</span></span><span style=display:flex><span>          <span style=color:#a2f>do</span> (<span style=color:#a2f>incf</span> <span style=color:#b8860b>s</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>)))
</span></span><span style=display:flex><span>          <span style=color:#b8860b>finally</span> (<span style=color:#a2f>return</span> <span style=color:#b8860b>s</span>))))
</span></span></code></pre></td></tr></table></div></div><p>We&rsquo;ve also had to add lines 8 and 9 to replicate what the <code>sum</code> keyword is
providing in the loop.</p><p>The results were staggering when I first saw them.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v6 - 11.116839ms
</span></span></code></pre></div><p>We took an order of magnitude off the run-time and are now in the realms of the
NumPy - hand tuned, optimised and mostly unreadable, C.</p><h2 id=optimise-for-speed-again>Optimise for speed, again<a hidden class=anchor aria-hidden=true href=#optimise-for-speed-again>#</a></h2><p>Again, let&rsquo;s be explicit that we want SPEED.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>dot-v7</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>optimize</span> <span style=color:#b8860b>speed</span>)
</span></span><span style=display:flex><span>           (<span style=color:#a2f;font-weight:700>type</span> (<span style=color:#0b0;font-weight:700>simple-array</span> <span style=color:#0b0;font-weight:700>single-float</span> (<span style=color:#00a000>*</span>)) <span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>size1</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>))
</span></span><span style=display:flex><span>        (<span style=color:#b8860b>size2</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>assert</span> (<span style=color:#b8860b>cl:=</span> <span style=color:#b8860b>size1</span> <span style=color:#b8860b>size2</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#b8860b>size1</span>
</span></span><span style=display:flex><span>          <span style=color:#b8860b>with</span> <span style=color:#b8860b>s</span> <span style=color:#b8860b>of-type</span> <span style=color:#0b0;font-weight:700>single-float</span> <span style=color:#00a000>=</span> <span style=color:#666>0.0</span>
</span></span><span style=display:flex><span>          <span style=color:#a2f>do</span> (<span style=color:#a2f>incf</span> <span style=color:#b8860b>s</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>)))
</span></span><span style=display:flex><span>          <span style=color:#b8860b>finally</span> (<span style=color:#a2f>return</span> <span style=color:#b8860b>s</span>))))
</span></span></code></pre></div><p>The lisp implementation I&rsquo;m using (<a href=http://www.sbcl.org/>SBCL</a>) is already <em>a high performance Common
Lisp compiler</em>, so there&rsquo;s not much to be squeezed out here.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v7 - 10.600901ms
</span></span></code></pre></div><h2 id=adding-type-information-to-the-loop-array-index>Adding type information to the loop: array index<a hidden class=anchor aria-hidden=true href=#adding-type-information-to-the-loop-array-index>#</a></h2><p>We can help the compiler out a little more by letting it know that the loop
variable <code>i</code> is for indexing arrays:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>dot-v8</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>optimize</span> <span style=color:#b8860b>speed</span>)
</span></span><span style=display:flex><span>           (<span style=color:#a2f;font-weight:700>type</span> (<span style=color:#0b0;font-weight:700>simple-array</span> <span style=color:#0b0;font-weight:700>single-float</span> (<span style=color:#00a000>*</span>)) <span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>size1</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>))
</span></span><span style=display:flex><span>        (<span style=color:#b8860b>size2</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>assert</span> (<span style=color:#b8860b>cl:=</span> <span style=color:#b8860b>size1</span> <span style=color:#b8860b>size2</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>of-type</span> <span style=color:#b8860b>alexandria:array-index</span> <span style=color:#b8860b>below</span> <span style=color:#b8860b>size1</span>
</span></span><span style=display:flex><span>          <span style=color:#b8860b>with</span> <span style=color:#b8860b>s</span> <span style=color:#b8860b>of-type</span> <span style=color:#0b0;font-weight:700>single-float</span> <span style=color:#00a000>=</span> <span style=color:#666>0.0</span>
</span></span><span style=display:flex><span>          <span style=color:#a2f>do</span> (<span style=color:#a2f>incf</span> <span style=color:#b8860b>s</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>)))
</span></span><span style=display:flex><span>          <span style=color:#b8860b>finally</span> (<span style=color:#a2f>return</span> <span style=color:#b8860b>s</span>))))
</span></span></code></pre></div><p>With this we can squeeze out a little more speed, but to be honest this result
fluctuated depending on what else my computer was doing.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>v8 - 10.57616ms
</span></span></code></pre></div><h2 id=almost-the-end>Almost the end<a hidden class=anchor aria-hidden=true href=#almost-the-end>#</a></h2><p>At this point I would look into <code>defgeneric</code> where I can define multiple <code>dot</code>
functions each optimised for different inputs, so <code>double-float</code>,
<code>complex-float</code>, etc. This is similar to overloading in other languages.
However, I&rsquo;ll leave that for another day.</p><p>Now, if this was a language benchmark post, I&rsquo;d stop here. However, I want to
use this dot function in a practical use case. That&rsquo;s what I do in some
following articles where I build a <a href=https://stewart123579.github.io/blog/categories/ai-ml-lisp/>AI/ML model</a>
(a neural network in fact) in lisp.</p><h2 id=finally>Finally<a hidden class=anchor aria-hidden=true href=#finally>#</a></h2><p>Let&rsquo;s compare the initial function and the optimised one:</p><div class=highlight><div style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>final-dot</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>optimize</span> <span style=color:#b8860b>speed</span>)
</span></span><span style=display:flex><span>           (<span style=color:#a2f;font-weight:700>type</span> (<span style=color:#0b0;font-weight:700>simple-array</span> <span style=color:#0b0;font-weight:700>single-float</span> (<span style=color:#00a000>*</span>)) <span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>))
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>size1</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>))
</span></span><span style=display:flex><span>        (<span style=color:#b8860b>size2</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array2</span>)))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>assert</span> (<span style=color:#b8860b>cl:=</span> <span style=color:#b8860b>size1</span> <span style=color:#b8860b>size2</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>of-type</span> <span style=color:#b8860b>alexandria:array-index</span> <span style=color:#b8860b>below</span> <span style=color:#b8860b>size1</span>
</span></span><span style=display:flex><span>          <span style=color:#b8860b>with</span> <span style=color:#b8860b>s</span> <span style=color:#b8860b>of-type</span> <span style=color:#0b0;font-weight:700>single-float</span> <span style=color:#00a000>=</span> <span style=color:#666>0.0</span>
</span></span><span style=display:flex><span>          <span style=color:#a2f>do</span> (<span style=color:#a2f>incf</span> <span style=color:#b8860b>s</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>)))
</span></span><span style=display:flex><span>          <span style=color:#b8860b>finally</span> (<span style=color:#a2f>return</span> <span style=color:#b8860b>s</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>initial-dot</span> (<span style=color:#b8860b>array1</span> <span style=color:#b8860b>array2</span>)
</span></span><span style=display:flex><span>  (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>array1</span>)
</span></span><span style=display:flex><span>        <span style=color:#b8860b>sum</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array1</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>array2</span> <span style=color:#b8860b>i</span>))))
</span></span></code></pre></td></tr></table></div></div><dl><dt>Line 1</dt><dd>Defining the function <em>[Same as line 13]</em></dd><dt>Line 2</dt><dd>Tell the compiler we want fast code</dd><dt>Line 3</dt><dd>Tell the compiler the arguments are <code>single-float</code></dd><dt>Lines 4 &ndash; 6</dt><dd>Check to see that the vectors are the same length</dd><dt>Line 7</dt><dd>Create our iterating variable <em>[Effectively, same as line 14]</em></dd><dt>Line 8</dt><dd>Tell the compiler that our accumulator variable <code>s</code> is a <code>single-float</code></dd><dt>Lines 9 & 10</dt><dd>Sum up the product of the array elements <em>[Same as line 15]</em></dd></dl><p>Effectively, by adding lines 3 and 8 we have taken the time to calculate the dot
product from 270ms down to 10.576ms, speeding it up by more than 25 times and
ending with a run time that is comparable to Numpy (11.154ms -
<a href=/blog/posts/code/calculating-a-dot-product/>previously </a>).</p><h3 id=an-aside-dot-dot-dot>An aside&mldr;<a hidden class=anchor aria-hidden=true href=#an-aside-dot-dot-dot>#</a></h3><p>Why did I say the lines 9 & 10 are the same as line 15?</p><p>The <code>loop</code> macro in common lisp is incredibly versatile.</p><p>The code generated by these two loops is virtually identical</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span><span style=color:#080;font-style:italic>;; Loop version 1</span>
</span></span><span style=display:flex><span>(<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#666>5</span>
</span></span><span style=display:flex><span>      <span style=color:#b8860b>sum</span> <span style=color:#b8860b>i</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>;; Loop version 2</span>
</span></span><span style=display:flex><span>(<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#666>5</span>
</span></span><span style=display:flex><span>      <span style=color:#b8860b>with</span> <span style=color:#b8860b>s</span> <span style=color:#00a000>=</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span>      <span style=color:#a2f>do</span> (<span style=color:#a2f>incf</span> <span style=color:#b8860b>s</span> <span style=color:#b8860b>i</span>)
</span></span><span style=display:flex><span>      <span style=color:#b8860b>finally</span> (<span style=color:#a2f>return</span> <span style=color:#b8860b>s</span>))
</span></span></code></pre></div><p>The only real difference is the variable <code>#:LOOP-SUM-708</code> in this first code
block acting as a proxy for <code>S</code> in the second loop.</p><p>This is the expansion of the first loop (using <code>(macroexpand-1 '(loop for i below 5 sum i))</code>):</p><div class=highlight><div style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f;font-weight:700>block</span> <span style=color:#800>nil</span>
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>i</span> <span style=color:#666>0</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>ignorable</span> <span style=color:#b8860b>i</span>)
</span></span><span style=display:flex><span>             (<span style=color:#a2f;font-weight:700>type</span> (<span style=color:#a2f>and</span> <span style=color:#00f>number</span> <span style=color:#00f>real</span>) <span style=color:#b8860b>i</span>))
</span></span><span style=display:flex><span>    (<span style=color:#080;font-style:italic>;; some sbcl specific defintions of the loop</span>
</span></span><span style=display:flex><span>     <span style=color:#080;font-style:italic>;; variable #:loop-sum-708</span>
</span></span><span style=display:flex><span>     (<span style=color:#a2f;font-weight:700>tagbody</span>
</span></span><span style=display:flex><span>      <span style=color:#b8860b>sb-loop::next-loop</span>
</span></span><span style=display:flex><span>        (<span style=color:#a2f>when</span> (<span style=color:#00a000>&gt;=</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>&#39;5</span>) (<span style=color:#a2f;font-weight:700>go</span> <span style=color:#b8860b>sb-loop::end-loop</span>))
</span></span><span style=display:flex><span>        (<span style=color:#a2f;font-weight:700>setq</span> <span style=color:#b8860b>#:loop-sum-708</span> (<span style=color:#00a000>+</span> <span style=color:#b8860b>#:loop-sum-708</span> <span style=color:#b8860b>i</span>))
</span></span><span style=display:flex><span>        (<span style=color:#b8860b>sb-loop::loop-desetq</span> <span style=color:#b8860b>i</span> (<span style=color:#00a000>1+</span> <span style=color:#b8860b>i</span>))
</span></span><span style=display:flex><span>        (<span style=color:#a2f;font-weight:700>go</span> <span style=color:#b8860b>sb-loop::next-loop</span>)
</span></span><span style=display:flex><span>      <span style=color:#b8860b>sb-loop::end-loop</span>
</span></span><span style=display:flex><span>        (<span style=color:#a2f;font-weight:700>return-from</span> <span style=color:#800>nil</span> <span style=color:#b8860b>#:loop-sum-708</span>)))))
</span></span></code></pre></td></tr></table></div></div><p>The expansion of the second loop, where lines 5 & 6 (defining the variable <code>S</code>)
are the only material differences.</p><div class=highlight><div style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f;font-weight:700>block</span> <span style=color:#800>nil</span>
</span></span><span style=display:flex><span>  (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>i</span> <span style=color:#666>0</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>ignorable</span> <span style=color:#b8860b>i</span>)
</span></span><span style=display:flex><span>             (<span style=color:#a2f;font-weight:700>type</span> (<span style=color:#a2f>and</span> <span style=color:#00f>number</span> <span style=color:#00f>real</span>) <span style=color:#b8860b>i</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>s</span> <span style=color:#666>0</span>))
</span></span><span style=display:flex><span>      (<span style=color:#a2f;font-weight:700>declare</span> (<span style=color:#a2f;font-weight:700>ignorable</span> <span style=color:#b8860b>s</span>))
</span></span><span style=display:flex><span>      (<span style=color:#a2f;font-weight:700>tagbody</span>
</span></span><span style=display:flex><span>       <span style=color:#b8860b>sb-loop::next-loop</span>
</span></span><span style=display:flex><span>         (<span style=color:#a2f>when</span> (<span style=color:#00a000>&gt;=</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>&#39;5</span>) (<span style=color:#a2f;font-weight:700>go</span> <span style=color:#b8860b>sb-loop::end-loop</span>))
</span></span><span style=display:flex><span>         (<span style=color:#a2f>incf</span> <span style=color:#b8860b>s</span> <span style=color:#b8860b>i</span>)
</span></span><span style=display:flex><span>         (<span style=color:#b8860b>sb-loop::loop-desetq</span> <span style=color:#b8860b>i</span> (<span style=color:#00a000>1+</span> <span style=color:#b8860b>i</span>))
</span></span><span style=display:flex><span>         (<span style=color:#a2f;font-weight:700>go</span> <span style=color:#b8860b>sb-loop::next-loop</span>)
</span></span><span style=display:flex><span>       <span style=color:#b8860b>sb-loop::end-loop</span>
</span></span><span style=display:flex><span>         (<span style=color:#a2f>return</span> <span style=color:#b8860b>s</span>)))))
</span></span></code></pre></td></tr></table></div></div><p>In case you were wondering about the <code>(incf s i)</code> in line 10</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#00a000>macroexpand-1</span> <span style=color:#666>&#39;</span>(<span style=color:#a2f>incf</span> <span style=color:#b8860b>s</span> <span style=color:#b8860b>i</span>))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>(setq s (+ i s))
</span></span></code></pre></div><p>which is the same form as line 10 in the first expansion.</p><p>Aren&rsquo;t lisp macros amazing!?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://stewart123579.github.io/blog/tags/lisp/>lisp</a></li><li><a href=https://stewart123579.github.io/blog/tags/100daystooffload/>100daysToOffload</a></li><li><a href=https://stewart123579.github.io/blog/tags/ai-ml/>AI / ML</a></li></ul><nav class=paginav><a class=prev href=https://stewart123579.github.io/blog/posts/code/magicl-contributions/><span class=title>« Prev Page</span><br><span>magicl contributions</span></a>
<a class=next href=https://stewart123579.github.io/blog/posts/code/calculating-a-dot-product/><span class=title>Next Page »</span><br><span>Calculating a DOT product</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Making (pure) lisp functions faster on twitter" href="https://twitter.com/intent/tweet/?text=Making%20%28pure%29%20lisp%20functions%20faster&url=https%3a%2f%2fstewart123579.github.io%2fblog%2fposts%2fcode%2fmaking-pure-lisp-functions-faster%2f&hashtags=lisp%2c100daysToOffload%2cai-ml"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making (pure) lisp functions faster on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fstewart123579.github.io%2fblog%2fposts%2fcode%2fmaking-pure-lisp-functions-faster%2f&title=Making%20%28pure%29%20lisp%20functions%20faster&summary=Making%20%28pure%29%20lisp%20functions%20faster&source=https%3a%2f%2fstewart123579.github.io%2fblog%2fposts%2fcode%2fmaking-pure-lisp-functions-faster%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making (pure) lisp functions faster on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstewart123579.github.io%2fblog%2fposts%2fcode%2fmaking-pure-lisp-functions-faster%2f&title=Making%20%28pure%29%20lisp%20functions%20faster"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making (pure) lisp functions faster on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstewart123579.github.io%2fblog%2fposts%2fcode%2fmaking-pure-lisp-functions-faster%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making (pure) lisp functions faster on whatsapp" href="https://api.whatsapp.com/send?text=Making%20%28pure%29%20lisp%20functions%20faster%20-%20https%3a%2f%2fstewart123579.github.io%2fblog%2fposts%2fcode%2fmaking-pure-lisp-functions-faster%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making (pure) lisp functions faster on telegram" href="https://telegram.me/share/url?text=Making%20%28pure%29%20lisp%20functions%20faster&url=https%3a%2f%2fstewart123579.github.io%2fblog%2fposts%2fcode%2fmaking-pure-lisp-functions-faster%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//stewart123579-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2022 <a href=https://stewart123579.github.io/blog/>SVW Thunk'd</a></span>
<span>|
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> |
<a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a> |
<a href=https://www.gnu.org/software/emacs/ rel=noopener target=_blank>Emacs</a> |
<a href=https://orgmode.org/ rel=noopener target=_blank>Org Mode</a> |
<a href=https://ox-hugo.scripter.co/ rel=noopener target=_blank>ox-hugo</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>