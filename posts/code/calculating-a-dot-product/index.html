<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Calculating a DOT product | SVW Thunk'd</title><meta name=keywords content="lisp,ai-ml,python,100daysToOffload"><meta name=description content="You can get high speed, numerical calculation output without having to resort to bug-prone, highly tuned and optimised, unreadable code."><meta name=author content="Stewart V. Wright"><link rel=canonical href=https://stewart123579.github.io/blog/posts/code/calculating-a-dot-product/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://stewart123579.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://stewart123579.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://stewart123579.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://stewart123579.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://stewart123579.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity=sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js integrity=sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<link rel=canonical href=https://stewart123579.github.io/blog/posts/code/calculating-a-dot-product/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/lightgallery/2.4.0/css/lightgallery-bundle.min.css integrity="sha512-91yJwfiGTCo9TM74ZzlAIAN4Eh5EWHpQJUfvo/XhpH6lzQtiRFkFRW1W+JSg4ch4XW3/xzh+dY4TOw/ILpavQA==" crossorigin=anonymous referrerpolicy=no-referrer><style>.flex-container{display:flex;flex-flow:row wrap;justify-content:space-around}</style><meta property="og:title" content="Calculating a DOT product"><meta property="og:description" content="You can get high speed, numerical calculation output without having to resort to bug-prone, highly tuned and optimised, unreadable code."><meta property="og:type" content="article"><meta property="og:url" content="https://stewart123579.github.io/blog/posts/code/calculating-a-dot-product/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-23T00:00:00+10:00"><meta property="article:modified_time" content="2022-06-23T00:00:00+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Calculating a DOT product"><meta name=twitter:description content="You can get high speed, numerical calculation output without having to resort to bug-prone, highly tuned and optimised, unreadable code."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://stewart123579.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Code","item":"https://stewart123579.github.io/blog/posts/code/"},{"@type":"ListItem","position":3,"name":"Calculating a DOT product","item":"https://stewart123579.github.io/blog/posts/code/calculating-a-dot-product/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Calculating a DOT product","name":"Calculating a DOT product","description":"You can get high speed, numerical calculation output without having to resort to bug-prone, highly tuned and optimised, unreadable code.","keywords":["lisp","ai-ml","python","100daysToOffload"],"articleBody":"It should go without saying: Choose the right programming language for your problem.\ntl;dr - You can get high speed, numerical calculation output without having to resort to bug-prone, highly tuned and optimised, unreadable code.\nHere I explore the code and efficiency (or more accurately run-time) of taking dot product on two vectors that are each ten million elements long. I’ll look at python, R and common lisp and in each case implement the dot product myself as well as using an optimised package for the library. The fastest implementation may surprise you.\nThis is not a post on benchmarking, the timings in the final section aren’t taken on a particularly powerful machine1 or intended to be rigorous; the timings are simply to show that rapid prototyping, followed by optimising what matters can be worthwhile. It was, however motivated by my question on Reddit.\nThis post appears in the following categories: code AI / ML in common lisp — Implementing AI and Machine Learning tools in common lisp.\nLisp versus X — A different perspective is always valuable. What’s a dot product and why do I care? A dot product between two vectors \\(A\\) and \\(B\\) can be thought of as the sum of the product of the elements, i.e.\n\\begin{align} A \\cdot B \u0026=\t\\sum_{i=1}^{n}a_{i}\\,b_{i} \\\\ \u0026= a_{1}\\,b_{1} + a_{2}\\,b_{2} + \\ldots \\end{align}\nSo why do I (or should you) care? Dot products are pretty fundamental to machine learning - as I’ll show in some upcoming posts. That means, when you have lots of data, you’re doing this operation lots of times. So how well your language implements this matters.\nLet’s look at two common (and one not so common2) languages and timings.\nA python implementation Python is the go-to language for machine-learning practitioners currently. There are many extremely powerful frameworks like PyTorch, TensorFlow among others. They are primarily built upon NumPy. If you’re reading this post, you probably know all of this.\nLet’s set up our random vectors…\nimport time import numpy as np # How big do we want the vector to be? 10 million! n = 10000000 # Make two arrays of 10 million random numbers a = np.random.rand(n) b = np.random.rand(n) Naïve loop If we were to evaluate the dot product with a loop over each of the elements it would look something like\ndef dot_prod_loop(): n = len(a) tic = time.time() c = 0 for i in range(n): c += a[i] * b[i] toc = time.time() print(f\"Python: loop version: {1000*(toc-tic):.3f}ms\") # Run it dot_prod_loop() Python: loop version: 3632.499ms NumPy Naturally, we can do better by using the NumPy implementation:\ndef dot_prod_numpy(): tic = time.time() c = np.dot(a,b) toc = time.time() print(f\"Python: numpy version: {1000*(toc-tic):.3f}ms\") # Run it dot_prod_numpy() Python: numpy version: 11.154ms So the “vectorised” python version is about 330 times faster!\nOf course this is a somewhat unfair comparison, because the NumPy version is actually highly optimised and compiled C code. It’s not pretty or concise (and that’s coming from someone who chooses to code in C!), but it’s fast.\nAn alternative implementation in R I used to write a lot in R, so I thought I’d dust it off for a comparison.\nSetting our random vectors again\nn \u003c- 10000000 a \u003c- runif(n) b \u003c- runif(n) Naïve loop As with the python case loop over each of the elements\n# Loop tic = Sys.time() result = 0 for (i in 1:length(a)) result = result + a[i] * b[i] toc = Sys.time() cat(\"R: loop version: \", round(1000*(toc-tic), 3), \"ms\\n\") R: loop version: 533.698 ms Around 7 times faster than the naïve python implementation. Not bad.\nSum the element-wise multiplication An alternative is to use the built-in element-wise multiplication feature and sum up the results\n# Another simplistic approach tic = Sys.time() result = sum(a*b) toc = Sys.time() cat(\"R: summing element-wise multiplication version: \", round(1000*(toc-tic), 3), \"ms\\n\") R: summing element-wise multiplication version: 1599.384 ms Ouch. This is not what I would have expected using native functions.\nBuilt-in matrix multiplication As R is a language built for mathematical operations, we could just use the built-in matrix multiplication operation.\n# Built in dot product tic = Sys.time() result = a %*% b toc = Sys.time() cat(\"R: Base matrix multiplication version: \", round(1000*(toc-tic), 3), \"ms\\n\") R: Base matrix multiplication version: 32.981 ms As expected, this looks to have been optimised reasonably well.\nGeometry library How about a library that provides a dot function? It’s compiled code so you’d expect it to be fast. I saw this suggestion on StackOverflow.\nlibrary(geometry) tic = Sys.time() result = dot(a, b) toc = Sys.time() cat(\"R: geometry dot version: \", round(1000*(toc-tic), 3), \"ms\\n\") R: geometry dot version: 386.445 ms This is unexpectedly slow.\nLike python, a lot of R’s packages aren’t actually written in R they’re C, C++ and Fortran to get the speed you want.\nCommon lisp implementations How about common lisp?\nSet up our random vector yet again. It’s lisp, so let’s just use a list.\n(defun randvect (length) \"A simple list (length LENTH) of random numbers [0,1)\" (loop for i below length collect (random 1.0))) (defparameter n 10000000) (defparameter a (randvect n)) (defparameter b (randvect n)) Now, let’s use some of the power of common lisp and write a macro to make generating the timing functions easier. If that sentence doesn’t make sense, this is just a quick way to duplicate the same code across all of my timing functions.\n(defmacro mytime (name description \u0026body body) \"Create a function called NAME to get timing when running BODY\" `(defun ,name () (let ((tic) (toc)) (setf tic (get-internal-real-time)) ,@body (setf toc (get-internal-real-time)) (format t \"lisp: ~a version: ~fms~\u0026\" ,description (/ (- toc tic) (/ internal-time-units-per-second 1000)))))) Naïve loop Let’s try two different looping approaches.\nv1 One of the simplest data types in lisp is the list, it’s not a numerical type like in other languages, it’s just a linked list of elements… v2 Let’s test an array object, this would perhaps be preferable? (mytime naive-dot-v1 \"naive loop v1\" (loop for i in a for j in b sum (* i j))) ;; Let's make our lists arrays (defparameter aa (make-array (list (length a)) :initial-contents a)) (defparameter ab (make-array (list (length b)) :initial-contents b)) (mytime naïve-dot-v2 \"naïve loop v2\" (loop for i below (length aa) sum (* (aref aa i) (aref ab i)))) (naive-dot-v1) (naïve-dot-v2) lisp: naive loop v1 version: 163.385ms lisp: naïve loop v2 version: 270.050ms Slower than the best python and R implementations, but not bad for a first pass approach for a non-numerical language.\nMagicl library We can optimise pure lisp, to make it fast…\n(defparameter ma (magicl:from-list a (list n))) (defparameter mb (magicl:from-list b (list n))) (mytime magicl-dot \"magicl pure lisp\" (magicl:dot ma mb)) (magicl-dot) lisp: magicl pure lisp version: 11.042ms Ever so slightly slower than the NumPy version (\u003c 1 ms), but not bad at all for pure lisp.\nSo, what does “optimised” pure lisp look like? Well, that’s for another write up on Making (pure) lisp functions faster . I’ve put quotes around optimised as this isn’t a fancy algorithm, it’s simply putting variable type hints in the code. The implementation I’ll discuss is a little bit of a cheat compared to MAGICL; I haven’t generalised it to work for complex numbers - unlike the MAGICL implementation.\nWhat I will do in this post is share the result…\nlisp: array-dot-lisp version: 10.576ms Python vs. R vs. lisp - timing What does the following table show us? Python (NumPy), R and common lisp can all produce code that is comparably fast, but in each case you need to think a little bit about your problem set and choose the right approach.\nThe other take-away that I think is important is that (for my use case!) it appears to take considerably less effort and development skill - and is less bug-prone - to take a rapid prototype in lisp and convert it to a fast, production ready implementation than it would in python and R.\nLanguage Implementation Time (ms) Rel. to numpy lisp Pure lisp 10.576 0.9 Python Numpy 11.154 1.0 lisp Magicl pure lisp 11.042 1.0 R Matrix multiplication 32.981 3.0 lisp Naïve loop (v1) 163.385 14.6 lisp Naïve loop (v2) 270.050 24.2 R Geometry library 386.445 34.6 R Naïve loop 533.698 47.8 R Sum element product 1599.384 143.4 Python Naïve loop 3632.499 325.7 The computer was a Early 2015 MacBook Air, 2.2 GHz Dual-Core Intel Core i7 with 8 GB of memory. ↩︎\nThis wasn’t intended as a pun, but I’ll take it! ↩︎\n","wordCount":"1416","inLanguage":"en","datePublished":"2022-06-23T00:00:00+10:00","dateModified":"2022-06-23T00:00:00+10:00","author":[{"@type":"Person","name":"Stewart V. Wright"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://stewart123579.github.io/blog/posts/code/calculating-a-dot-product/"},"publisher":{"@type":"Organization","name":"SVW Thunk'd","logo":{"@type":"ImageObject","url":"https://stewart123579.github.io/blog/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://stewart123579.github.io/blog/ accesskey=h title="SVW Thunk'd (Alt + H)">SVW Thunk'd</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://stewart123579.github.io/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://stewart123579.github.io/blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://stewart123579.github.io/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://stewart123579.github.io/blog/archives/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://stewart123579.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://stewart123579.github.io/blog/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://stewart123579.github.io/blog/posts/code/>Code</a></div><h1 class=post-title>Calculating a DOT product</h1><div class=post-meta><span title='2022-06-23 00:00:00 +1000 AEST'>June 23, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Stewart V. Wright</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-s-a-dot-product-and-why-do-i-care aria-label="What&amp;rsquo;s a dot product and why do I care?">What&rsquo;s a dot product and why do I care?</a></li><li><a href=#a-python-implementation aria-label="A python implementation">A python implementation</a><ul><li><a href=#na%c3%afve-loop aria-label="Naïve loop">Naïve loop</a></li><li><a href=#numpy aria-label=NumPy>NumPy</a></li></ul></li><li><a href=#an-alternative-implementation-in-r aria-label="An alternative implementation in R">An alternative implementation in R</a><ul><li><a href=#na%c3%afve-loop aria-label="Naïve loop">Naïve loop</a></li><li><a href=#sum-the-element-wise-multiplication aria-label="Sum the element-wise multiplication">Sum the element-wise multiplication</a></li><li><a href=#built-in-matrix-multiplication aria-label="Built-in matrix multiplication">Built-in matrix multiplication</a></li><li><a href=#geometry-library aria-label="Geometry library">Geometry library</a></li></ul></li><li><a href=#common-lisp-implementations aria-label="Common lisp implementations">Common lisp implementations</a><ul><li><a href=#na%c3%afve-loop aria-label="Naïve loop">Naïve loop</a></li><li><a href=#magicl-library aria-label="Magicl library">Magicl library</a></li><li><a href=#so-what-does-optimised-pure-lisp-look-like aria-label="So, what does &amp;ldquo;optimised&amp;rdquo; pure lisp look like?">So, what does &ldquo;optimised&rdquo; pure lisp look like?</a></li></ul></li><li><a href=#python-vs-dot-r-vs-dot-lisp-timing aria-label="Python vs. R vs. lisp - timing">Python vs. R vs. lisp - timing</a></li></ul></div></details></div><div class=post-content><p>It should go without saying: Choose the right programming language for your
problem.</p><p><strong><em>tl;dr</em></strong> - You <em>can</em> get high speed, numerical calculation output <em><strong>without</strong></em>
having to resort to bug-prone, highly tuned and optimised, unreadable code.</p><p>Here I explore the code and efficiency (or more accurately run-time) of taking
dot product on two vectors that are each ten million elements long. I&rsquo;ll look at
python, R and common lisp and in each case implement the dot product myself as
well as using an optimised package for the library. The fastest implementation
may surprise you.</p><p>This is not a post on benchmarking, the timings in the <a href=#python-vs-dot-r-vs-dot-lisp-timing>final section</a> aren&rsquo;t
taken on a particularly powerful machine<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> or intended to be rigorous; the
timings are simply to show that rapid prototyping, followed by optimising what
matters can be worthwhile. It was, however motivated by <a href=https://www.reddit.com/r/Common_Lisp/comments/uoozp1/why_is_python_numpy_so_much_faster_than_lisp_in/>my question</a> on Reddit.</p><p>This post appears in the following categories:<ul><li><a href=https://stewart123579.github.io/blog/categories/code/>code</a></li><li><a href=https://stewart123579.github.io/blog/categories/ai-ml-lisp/>AI / ML in common lisp</a> &mdash;<p>Implementing AI and Machine Learning tools in common lisp.</p></li><li><a href=https://stewart123579.github.io/blog/categories/lisp-vs/>Lisp versus X</a> &mdash; A different perspective is always valuable.</li></ul></p><h2 id=what-s-a-dot-product-and-why-do-i-care>What&rsquo;s a dot product and why do I care?<a hidden class=anchor aria-hidden=true href=#what-s-a-dot-product-and-why-do-i-care>#</a></h2><p>A <a href=https://mathworld.wolfram.com/DotProduct.html>dot product</a> between two vectors \(A\) and \(B\) can be thought of as the sum of the product of the elements, i.e.</p><p>\begin{align}
A \cdot B &= \sum_{i=1}^{n}a_{i}\,b_{i} \\
&= a_{1}\,b_{1} + a_{2}\,b_{2} + \ldots
\end{align}</p><p>So why do I (or should you) care? Dot products are pretty fundamental to machine
learning - as I&rsquo;ll show in some upcoming posts. That means, when you have lots
of data, you&rsquo;re doing this operation lots of times. So how well your language
implements this matters.</p><p>Let&rsquo;s look at two common (and one not so common<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>) languages and timings.</p><h2 id=a-python-implementation>A python implementation<a hidden class=anchor aria-hidden=true href=#a-python-implementation>#</a></h2><p>Python is the go-to language for machine-learning practitioners currently. There
are many extremely powerful frameworks like <a href=https://pytorch.org/>PyTorch</a>, <a href=https://www.tensorflow.org/>TensorFlow</a> among others.
They are primarily built upon <a href=https://numpy.org/>NumPy</a>. If you&rsquo;re reading this post, you probably
know all of this.</p><p>Let&rsquo;s set up our random vectors&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>time</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> <span style=color:#00f;font-weight:700>numpy</span> <span style=color:#a2f;font-weight:700>as</span> <span style=color:#00f;font-weight:700>np</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># How big do we want the vector to be?  10 million!</span>
</span></span><span style=display:flex><span>n <span style=color:#666>=</span> <span style=color:#666>10000000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Make two arrays of 10 million random numbers</span>
</span></span><span style=display:flex><span>a <span style=color:#666>=</span> np<span style=color:#666>.</span>random<span style=color:#666>.</span>rand(n)
</span></span><span style=display:flex><span>b <span style=color:#666>=</span> np<span style=color:#666>.</span>random<span style=color:#666>.</span>rand(n)
</span></span></code></pre></div><h3 id=naïve-loop>Naïve loop<a hidden class=anchor aria-hidden=true href=#naïve-loop>#</a></h3><p>If we were to evaluate the dot product with a loop over each of the elements it
would look something like</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a2f;font-weight:700>def</span> <span style=color:#00a000>dot_prod_loop</span>():
</span></span><span style=display:flex><span>    n <span style=color:#666>=</span> <span style=color:#a2f>len</span>(a)
</span></span><span style=display:flex><span>    tic <span style=color:#666>=</span> time<span style=color:#666>.</span>time()
</span></span><span style=display:flex><span>    c <span style=color:#666>=</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> i <span style=color:#a2f;font-weight:700>in</span> <span style=color:#a2f>range</span>(n):
</span></span><span style=display:flex><span>        c <span style=color:#666>+=</span> a[i] <span style=color:#666>*</span> b[i]
</span></span><span style=display:flex><span>    toc <span style=color:#666>=</span> time<span style=color:#666>.</span>time()
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>f</span><span style=color:#b44>&#34;Python: loop version:  </span><span style=color:#b68;font-weight:700>{</span><span style=color:#666>1000</span><span style=color:#666>*</span>(toc<span style=color:#666>-</span>tic)<span style=color:#b68;font-weight:700>:</span><span style=color:#b44>.3f</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>ms&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Run it</span>
</span></span><span style=display:flex><span>dot_prod_loop()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Python: loop version:  3632.499ms
</span></span></code></pre></div><h3 id=numpy>NumPy<a hidden class=anchor aria-hidden=true href=#numpy>#</a></h3><p>Naturally, we can do better by using the <a href=https://numpy.org/>NumPy</a> implementation:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a2f;font-weight:700>def</span> <span style=color:#00a000>dot_prod_numpy</span>():
</span></span><span style=display:flex><span>    tic <span style=color:#666>=</span> time<span style=color:#666>.</span>time()
</span></span><span style=display:flex><span>    c <span style=color:#666>=</span> np<span style=color:#666>.</span>dot(a,b)
</span></span><span style=display:flex><span>    toc <span style=color:#666>=</span> time<span style=color:#666>.</span>time()
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>f</span><span style=color:#b44>&#34;Python: numpy version:  </span><span style=color:#b68;font-weight:700>{</span><span style=color:#666>1000</span><span style=color:#666>*</span>(toc<span style=color:#666>-</span>tic)<span style=color:#b68;font-weight:700>:</span><span style=color:#b44>.3f</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>ms&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Run it</span>
</span></span><span style=display:flex><span>dot_prod_numpy()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Python: numpy version:  11.154ms
</span></span></code></pre></div><p>So the &ldquo;vectorised&rdquo; python version is about 330 times faster!</p><p>Of course this is a somewhat unfair comparison, because the NumPy version is
actually highly optimised and compiled C code. It&rsquo;s <a href="https://github.com/numpy/numpy/blob/3544fae2859d8ecac378b9ddc8f909c69455a831/numpy/core/src/common/cblasfuncs.c#L210-L702=">not pretty or concise</a> (and
that&rsquo;s coming from someone who <em>chooses</em> to code in C!), but it&rsquo;s fast.</p><h2 id=an-alternative-implementation-in-r>An alternative implementation in R<a hidden class=anchor aria-hidden=true href=#an-alternative-implementation-in-r>#</a></h2><p>I used to write a lot in R, so I thought I&rsquo;d dust it off for a comparison.</p><p>Setting our random vectors again</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span>n <span style=color:#666>&lt;-</span> <span style=color:#666>10000000</span>
</span></span><span style=display:flex><span>a <span style=color:#666>&lt;-</span> <span style=color:#00a000>runif</span>(n)
</span></span><span style=display:flex><span>b <span style=color:#666>&lt;-</span> <span style=color:#00a000>runif</span>(n)
</span></span></code></pre></div><h3 id=naïve-loop>Naïve loop<a hidden class=anchor aria-hidden=true href=#naïve-loop>#</a></h3><p>As with the python case loop over each of the elements</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span><span style=color:#080;font-style:italic># Loop</span>
</span></span><span style=display:flex><span>tic <span style=color:#666>=</span> <span style=color:#00a000>Sys.time</span>()
</span></span><span style=display:flex><span>result <span style=color:#666>=</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span><span style=color:#00a000>for </span>(i in <span style=color:#666>1</span><span style=color:#666>:</span><span style=color:#00a000>length</span>(a))
</span></span><span style=display:flex><span>  result <span style=color:#666>=</span> result <span style=color:#666>+</span> a[i] <span style=color:#666>*</span> b[i]
</span></span><span style=display:flex><span>toc <span style=color:#666>=</span> <span style=color:#00a000>Sys.time</span>()
</span></span><span style=display:flex><span><span style=color:#00a000>cat</span>(<span style=color:#b44>&#34;R: loop version:  &#34;</span>, <span style=color:#00a000>round</span>(<span style=color:#666>1000</span><span style=color:#666>*</span>(toc<span style=color:#666>-</span>tic), <span style=color:#666>3</span>), <span style=color:#b44>&#34;ms\n&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>R: loop version:   533.698 ms
</span></span></code></pre></div><p>Around 7 times faster than the naïve python implementation. Not bad.</p><h3 id=sum-the-element-wise-multiplication>Sum the element-wise multiplication<a hidden class=anchor aria-hidden=true href=#sum-the-element-wise-multiplication>#</a></h3><p>An alternative is to use the built-in element-wise multiplication feature and
sum up the results</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span><span style=color:#080;font-style:italic># Another simplistic approach</span>
</span></span><span style=display:flex><span>tic <span style=color:#666>=</span> <span style=color:#00a000>Sys.time</span>()
</span></span><span style=display:flex><span>result <span style=color:#666>=</span> <span style=color:#00a000>sum</span>(a<span style=color:#666>*</span>b)
</span></span><span style=display:flex><span>toc <span style=color:#666>=</span> <span style=color:#00a000>Sys.time</span>()
</span></span><span style=display:flex><span><span style=color:#00a000>cat</span>(<span style=color:#b44>&#34;R: summing element-wise multiplication version:  &#34;</span>, <span style=color:#00a000>round</span>(<span style=color:#666>1000</span><span style=color:#666>*</span>(toc<span style=color:#666>-</span>tic), <span style=color:#666>3</span>), <span style=color:#b44>&#34;ms\n&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>R: summing element-wise multiplication version:   1599.384 ms
</span></span></code></pre></div><p>Ouch. This is not what I would have expected using native functions.</p><h3 id=built-in-matrix-multiplication>Built-in matrix multiplication<a hidden class=anchor aria-hidden=true href=#built-in-matrix-multiplication>#</a></h3><p>As R is a language built for mathematical operations, we could just use the
built-in matrix multiplication operation.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span><span style=color:#080;font-style:italic># Built in dot product</span>
</span></span><span style=display:flex><span>tic <span style=color:#666>=</span> <span style=color:#00a000>Sys.time</span>()
</span></span><span style=display:flex><span>result <span style=color:#666>=</span> a <span style=color:#666>%*%</span> b
</span></span><span style=display:flex><span>toc <span style=color:#666>=</span> <span style=color:#00a000>Sys.time</span>()
</span></span><span style=display:flex><span><span style=color:#00a000>cat</span>(<span style=color:#b44>&#34;R: Base matrix multiplication version:  &#34;</span>, <span style=color:#00a000>round</span>(<span style=color:#666>1000</span><span style=color:#666>*</span>(toc<span style=color:#666>-</span>tic), <span style=color:#666>3</span>), <span style=color:#b44>&#34;ms\n&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>R: Base matrix multiplication version:   32.981 ms
</span></span></code></pre></div><p>As expected, this looks to have been optimised reasonably well.</p><h3 id=geometry-library>Geometry library<a hidden class=anchor aria-hidden=true href=#geometry-library>#</a></h3><p>How about a library that provides a <code>dot</code> function? It&rsquo;s compiled code so you&rsquo;d
expect it to be fast. I saw this suggestion on StackOverflow.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-R data-lang=R><span style=display:flex><span><span style=color:#00a000>library</span>(geometry)
</span></span><span style=display:flex><span>tic <span style=color:#666>=</span> <span style=color:#00a000>Sys.time</span>()
</span></span><span style=display:flex><span>result <span style=color:#666>=</span> <span style=color:#00a000>dot</span>(a, b)
</span></span><span style=display:flex><span>toc <span style=color:#666>=</span> <span style=color:#00a000>Sys.time</span>()
</span></span><span style=display:flex><span><span style=color:#00a000>cat</span>(<span style=color:#b44>&#34;R: geometry dot version:  &#34;</span>, <span style=color:#00a000>round</span>(<span style=color:#666>1000</span><span style=color:#666>*</span>(toc<span style=color:#666>-</span>tic), <span style=color:#666>3</span>), <span style=color:#b44>&#34;ms\n&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>R: geometry dot version:   386.445 ms
</span></span></code></pre></div><p>This is unexpectedly slow.</p><p>Like python, a lot of R&rsquo;s packages aren&rsquo;t actually written in R they&rsquo;re C, C++
and Fortran to get the speed you want.</p><h2 id=common-lisp-implementations>Common lisp implementations<a hidden class=anchor aria-hidden=true href=#common-lisp-implementations>#</a></h2><p>How about common lisp?</p><p>Set up our random vector yet again. It&rsquo;s lisp, so let&rsquo;s just use a list.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defun</span> <span style=color:#b8860b>randvect</span> (<span style=color:#00a000>length</span>)
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;A simple list (length LENTH) of random numbers [0,1)&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> <span style=color:#00a000>length</span> <span style=color:#b8860b>collect</span> (<span style=color:#00a000>random</span> <span style=color:#666>1.0</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>n</span> <span style=color:#666>10000000</span>)
</span></span><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>a</span> (<span style=color:#b8860b>randvect</span> <span style=color:#b8860b>n</span>))
</span></span><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>b</span> (<span style=color:#b8860b>randvect</span> <span style=color:#b8860b>n</span>))
</span></span></code></pre></div><p>Now, let&rsquo;s use some of the power of common lisp and write a macro to make
generating the timing functions easier. If that sentence doesn&rsquo;t make sense,
this is just a quick way to duplicate the same code across all of my timing
functions.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defmacro</span> <span style=color:#b8860b>mytime</span> (<span style=color:#b8860b>name</span> <span style=color:#b8860b>description</span> <span style=color:#a2f;font-weight:700>&amp;body</span> <span style=color:#b8860b>body</span>)
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;Create a function called NAME to get timing when running BODY&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#666>`</span>(<span style=color:#a2f>defun</span> <span style=color:#666>,</span><span style=color:#b8860b>name</span> ()
</span></span><span style=display:flex><span>     (<span style=color:#a2f;font-weight:700>let</span> ((<span style=color:#b8860b>tic</span>)
</span></span><span style=display:flex><span>           (<span style=color:#b8860b>toc</span>))
</span></span><span style=display:flex><span>       (<span style=color:#a2f>setf</span> <span style=color:#b8860b>tic</span> (<span style=color:#00a000>get-internal-real-time</span>))
</span></span><span style=display:flex><span>       <span style=color:#666>,@</span><span style=color:#b8860b>body</span>
</span></span><span style=display:flex><span>       (<span style=color:#a2f>setf</span> <span style=color:#b8860b>toc</span> (<span style=color:#00a000>get-internal-real-time</span>))
</span></span><span style=display:flex><span>       (<span style=color:#00a000>format</span> <span style=color:#800>t</span> <span style=color:#b44>&#34;lisp: ~a version: ~fms~&amp;&#34;</span>
</span></span><span style=display:flex><span>               <span style=color:#666>,</span><span style=color:#b8860b>description</span>
</span></span><span style=display:flex><span>               (<span style=color:#00a000>/</span> (<span style=color:#00a000>-</span> <span style=color:#b8860b>toc</span> <span style=color:#b8860b>tic</span>) (<span style=color:#00a000>/</span> <span style=color:#b8860b>internal-time-units-per-second</span> <span style=color:#666>1000</span>))))))
</span></span></code></pre></div><h3 id=naïve-loop>Naïve loop<a hidden class=anchor aria-hidden=true href=#naïve-loop>#</a></h3><p>Let&rsquo;s try two different looping approaches.</p><dl><dt><code>v1</code></dt><dd>One of the simplest data types in lisp is the list, it&rsquo;s not a
numerical type like in other languages, it&rsquo;s <em>just</em> a linked list of
elements&mldr;</dd><dt><code>v2</code></dt><dd>Let&rsquo;s test an array object, this would perhaps be preferable?</dd></dl><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#b8860b>mytime</span> <span style=color:#b8860b>naive-dot-v1</span> <span style=color:#b44>&#34;naive loop v1&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>in</span> <span style=color:#b8860b>a</span>
</span></span><span style=display:flex><span>        <span style=color:#b8860b>for</span> <span style=color:#b8860b>j</span> <span style=color:#b8860b>in</span> <span style=color:#b8860b>b</span>
</span></span><span style=display:flex><span>        <span style=color:#b8860b>sum</span> (<span style=color:#00a000>*</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>j</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>;; Let&#39;s make our lists arrays</span>
</span></span><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>aa</span> (<span style=color:#00a000>make-array</span> (<span style=color:#00f>list</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>a</span>)) <span style=color:#b8860b>:initial-contents</span> <span style=color:#b8860b>a</span>))
</span></span><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>ab</span> (<span style=color:#00a000>make-array</span> (<span style=color:#00f>list</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>b</span>)) <span style=color:#b8860b>:initial-contents</span> <span style=color:#b8860b>b</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#b8860b>mytime</span> <span style=color:#b8860b>na</span><span>ï</span><span style=color:#b8860b>ve-dot-v2</span> <span style=color:#b44>&#34;naïve loop v2&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#a2f>loop</span> <span style=color:#b8860b>for</span> <span style=color:#b8860b>i</span> <span style=color:#b8860b>below</span> (<span style=color:#00a000>length</span> <span style=color:#b8860b>aa</span>)
</span></span><span style=display:flex><span>        <span style=color:#b8860b>sum</span> (<span style=color:#00a000>*</span> (<span style=color:#00a000>aref</span> <span style=color:#b8860b>aa</span> <span style=color:#b8860b>i</span>) (<span style=color:#00a000>aref</span> <span style=color:#b8860b>ab</span> <span style=color:#b8860b>i</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#b8860b>naive-dot-v1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#b8860b>na</span><span>ï</span><span style=color:#b8860b>ve-dot-v2</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>lisp: naive loop v1 version: 163.385ms
</span></span><span style=display:flex><span>lisp: naïve loop v2 version: 270.050ms
</span></span></code></pre></div><p>Slower than the best python and R implementations, but not bad for a first pass
approach for a non-numerical language.</p><h3 id=magicl-library>Magicl library<a hidden class=anchor aria-hidden=true href=#magicl-library>#</a></h3><p>We can optimise <strong>pure</strong> lisp, to make it fast&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>ma</span> (<span style=color:#b8860b>magicl:from-list</span> <span style=color:#b8860b>a</span> (<span style=color:#00f>list</span> <span style=color:#b8860b>n</span>)))
</span></span><span style=display:flex><span>(<span style=color:#a2f>defparameter</span> <span style=color:#b8860b>mb</span> (<span style=color:#b8860b>magicl:from-list</span> <span style=color:#b8860b>b</span> (<span style=color:#00f>list</span> <span style=color:#b8860b>n</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#b8860b>mytime</span> <span style=color:#b8860b>magicl-dot</span> <span style=color:#b44>&#34;magicl pure lisp&#34;</span>
</span></span><span style=display:flex><span>  (<span style=color:#b8860b>magicl:dot</span> <span style=color:#b8860b>ma</span> <span style=color:#b8860b>mb</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#b8860b>magicl-dot</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>lisp: magicl pure lisp version: 11.042ms
</span></span></code></pre></div><p>Ever so slightly slower than the NumPy version (&lt; 1 ms), but not bad at all for <strong>pure</strong> lisp.</p><h3 id=so-what-does-optimised-pure-lisp-look-like>So, what does &ldquo;optimised&rdquo; pure lisp look like?<a hidden class=anchor aria-hidden=true href=#so-what-does-optimised-pure-lisp-look-like>#</a></h3><p>Well, that&rsquo;s for another write up on <a href=/blog/posts/code/making-pure-lisp-functions-faster/>Making (pure) lisp functions faster </a>. I&rsquo;ve put quotes around optimised
as this isn&rsquo;t a fancy algorithm, it&rsquo;s simply putting variable type hints in the
code. The implementation I&rsquo;ll discuss is a little bit of a cheat compared to
MAGICL; I haven&rsquo;t generalised it to work for complex numbers - unlike the MAGICL
implementation.</p><p>What I will do in this post is share the result&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>lisp: array-dot-lisp version: 10.576ms
</span></span></code></pre></div><hr><h2 id=python-vs-dot-r-vs-dot-lisp-timing>Python vs. R vs. lisp - timing<a hidden class=anchor aria-hidden=true href=#python-vs-dot-r-vs-dot-lisp-timing>#</a></h2><p>What does the following table show us? Python (NumPy), R <strong>and</strong> common lisp can
all produce code that is comparably fast, but in each case you need to think a
little bit about your problem set and choose the right approach.</p><p>The other take-away that I think is important is that <em>(for my use case!)</em> it
appears to take considerably less effort and development skill - and is less
bug-prone - to take a rapid prototype in lisp and convert it to a fast,
production ready implementation than it would in python and R.</p><table><thead><tr><th>Language</th><th>Implementation</th><th>Time (ms)</th><th>Rel. to numpy</th></tr></thead><tbody><tr><td>lisp</td><td>Pure lisp</td><td>10.576</td><td>0.9</td></tr><tr><td>Python</td><td>Numpy</td><td>11.154</td><td>1.0</td></tr><tr><td>lisp</td><td>Magicl pure lisp</td><td>11.042</td><td>1.0</td></tr><tr><td>R</td><td>Matrix multiplication</td><td>32.981</td><td>3.0</td></tr><tr><td>lisp</td><td>Naïve loop (v1)</td><td>163.385</td><td>14.6</td></tr><tr><td>lisp</td><td>Naïve loop (v2)</td><td>270.050</td><td>24.2</td></tr><tr><td>R</td><td>Geometry library</td><td>386.445</td><td>34.6</td></tr><tr><td>R</td><td>Naïve loop</td><td>533.698</td><td>47.8</td></tr><tr><td>R</td><td>Sum element product</td><td>1599.384</td><td>143.4</td></tr><tr><td>Python</td><td>Naïve loop</td><td>3632.499</td><td>325.7</td></tr></tbody></table><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The computer was a Early 2015 <em>MacBook Air</em>, 2.2 GHz Dual-Core Intel Core
i7 with 8 GB of memory.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>This wasn&rsquo;t <em>intended</em> as a pun, but I&rsquo;ll take it!&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://stewart123579.github.io/blog/tags/lisp/>lisp</a></li><li><a href=https://stewart123579.github.io/blog/tags/ai-ml/>AI / ML</a></li><li><a href=https://stewart123579.github.io/blog/tags/python/>python</a></li><li><a href=https://stewart123579.github.io/blog/tags/100daystooffload/>100daysToOffload</a></li></ul><nav class=paginav><a class=prev href=https://stewart123579.github.io/blog/posts/code/making-pure-lisp-functions-faster/><span class=title>« Prev Page</span><br><span>Making (pure) lisp functions faster</span></a>
<a class=next href=https://stewart123579.github.io/blog/posts/meetings-and-agendas/><span class=title>Next Page »</span><br><span>Meetings and agendas</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2023 <a href=https://stewart123579.github.io/blog/>SVW Thunk'd</a></span>
<span>|
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> |
<a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a> |
<a href=https://www.gnu.org/software/emacs/ rel=noopener target=_blank>Emacs</a> |
<a href=https://orgmode.org/ rel=noopener target=_blank>Org Mode</a> |
<a href=https://ox-hugo.scripter.co/ rel=noopener target=_blank>ox-hugo</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>